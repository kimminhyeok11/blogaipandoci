<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>몬배틀 헌터즈 (MonBattle Hunters)</title>
    <!-- Tailwind CSS, Tone.js, Supabase, anime.js -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* Base Styles */
        body { font-family: 'Noto Sans KR', sans-serif; background-color: #2d2d2d; color: #cccccc; }
        .view { display: none; }
        .view.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        .font-title { font-family: 'Black Han Sans', sans-serif; }

        /* Main Page Background Container */
        #pokedex-view-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 700px; 
            background-image: url('https://byepyjdvhggofjjwsqna.supabase.co/storage/v1/object/public/battle_images/main_bg.webp');
            background-size: cover;
            background-position: center top;
            background-repeat: no-repeat;
            z-index: -1;
            opacity: 0.5;
            -webkit-mask-image: linear-gradient(to bottom, black 60%, transparent 100%);
            mask-image: linear-gradient(to bottom, black 60%, transparent 100%);
        }
        #pokedex-view .max-w-7xl {
            position: relative;
            z-index: 1;
        }
        /* Mobile background fix */
        @media (max-width: 768px) {
            #pokedex-view-background {
                height: 60vh;
            }
        }

        /* Card Styles */
        .pokedex-card { background: #393939; border-left-width: 8px; transition: all 0.3s ease-in-out; cursor: pointer; position: relative; overflow: hidden; border-color: #515151; }
        .pokedex-card:hover { transform: translateY(-5px) scale(1.02); box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
        .stat-bar-bg { background-color: #515151; border-radius: 999px; }
        .stat-bar { transition: width 0.8s ease-out; border-radius: 999px; }
        .rank-display { position: absolute; bottom: 8px; right: 8px; background-color: rgba(0,0,0,0.7); color: white; padding: 4px 10px; border-radius: 12px; font-size: 0.8rem; font-weight: bold; }
        .level-display {
            position: absolute;
            top: 8px;
            right: 8px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #facc15; /* yellow-400 */
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            z-index: 2;
        }

        /* Type & Universe Badges */
        .type-badge { padding: 4px 12px; border-radius: 12px; font-weight: 700; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        .type-Normal { background-color: #A8A77A; } .type-Fire { background-color: #EE8130; }
        .type-Water { background-color: #6390F0; } .type-Electric { background-color: #F7D02C; }
        .type-Grass { background-color: #7AC74C; } .type-Ice { background-color: #96D9D6; }
        .type-Fighting { background-color: #C22E28; } .type-Poison { background-color: #A33EA1; }
        .type-Ground { background-color: #E2BF65; } .type-Flying { background-color: #A98FF3; }
        .type-Psychic { background-color: #F95587; } .type-Bug { background-color: #A6B91A; }
        .type-Rock { background-color: #B6A136; } .type-Ghost { background-color: #735797; }
        .type-Dragon { background-color: #6F35FC; } .type-Darkness { background-color: #705746; }
        .type-Steel { background-color: #B7B7CE; } .type-Fairy { background-color: #D685AD; }
        .type-Light { background: linear-gradient(45deg, #FFFDE4, #F9E79F); color: #B48A00; text-shadow: 0 0 2px white; }

        .universe-badge { font-size: 0.7rem; padding: 2px 8px; border-radius: 8px; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        .universe-에테리얼 { background: linear-gradient(45deg, #a7c5eb, #c5a7eb); color: white; }
        .universe-키티노이드 { background: linear-gradient(45deg, #7c5a4a, #a98675); color: white; }
        .universe-어비셜 { background: linear-gradient(45deg, #4b0082, #000000); color: #e0e0e0; }

        /* Rarity Styles */
        .rarity-badge { padding: 4px 12px; border-radius: 12px; font-weight: 900; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        .rarity-일반 { background-color: #B0BEC5; } .rarity-희귀 { background-color: #42A5F5; }
        .rarity-에픽 { background-color: #AB47BC; } .rarity-전설 { background: linear-gradient(45deg, #FFEE58, #F57F17); text-shadow: 0 0 2px black; }
        .rarity-고대 { background: linear-gradient(45deg, #4DB6AC, #004D40); text-shadow: 0 0 2px black; }
        .rarity-신화 { background: linear-gradient(45deg, #FF7043, #D84315, #BF360C); text-shadow: 0 0 2px black; }
        
        .card-border-일반 { border-color: #B0BEC5; } .card-border-희귀 { border-color: #42A5F5; }
        .card-border-에픽 { border-color: #AB47BC; } .card-border-전설 { border-color: #F57F17; }
        .card-border-고대 { border-color: #004D40; } .card-border-신화 { border-color: #BF360C; }

        /* Battle Arena Styles - Responsive Update */
        #battle-arena-view { position: relative; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
        #battle-background { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; background-size: cover; background-position: center; }
        .battle-ui-overlay { position: relative; z-index: 2; display: flex; flex-direction: column; flex-grow: 1; padding: 0.5rem; }
        .characters-area { flex-grow: 1; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 1rem; position: relative; }
        .opponent-container { grid-column: 2; grid-row: 1; display: flex; flex-direction: column; justify-content: flex-start; align-items: center; }
        .player-container { grid-column: 1; grid-row: 2; display: flex; flex-direction: column; justify-content: flex-end; align-items: center; }
        .battle-character-sprite { max-height: 40vh; object-fit: contain; }
        .battle-character-ui { width: 100%; max-width: 320px; }
        .controls-area { flex-shrink: 0; }
        
        .hp-bar-inner { transition: width 0.5s ease-in-out; }
        .battle-character-ui.desperate { box-shadow: 0 0 15px 5px rgba(255, 0, 0, 0.7); border: 1px solid rgba(255, 100, 100, 0.8); }
        .battle-moves-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; }
        .battle-move-item { background-color: rgba(0,0,0,0.5); padding: 8px; border-radius: 4px; font-size: 0.85rem; text-align: center; transition: all 0.2s ease; cursor: pointer; border: 1px solid #555; position: relative;}
        .battle-move-item:hover:not(:disabled) { background-color: rgba(255,255,255,0.1); transform: scale(1.05); border-color: #8abeb7;}
        .battle-move-item:disabled { background-color: rgba(50,50,50,0.5); cursor: not-allowed; color: #888; }
        .pp-display { font-size: 0.7rem; color: #a0a0a0; margin-left: 4px;}
        
        #move-tooltip { 
            position: fixed; 
            z-index: 10000;
            background-color: rgba(20, 20, 20, 0.95);
            border: 1px solid #555;
            border-radius: 8px;
            padding: 12px;
            width: 280px;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.2s ease, transform 0.2s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
        }

        /* General UI Components */
        .filter-btn { padding: 8px 16px; border-radius: 8px; font-weight: bold; transition: all 0.2s; }
        .filter-btn.active { background-color: #8abeb7; color: white; }
        .filter-btn:not(.active) { background-color: #515151; color: #cccccc; }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #515151;
            transition: .4s;
            border-radius: 28px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: #8abeb7; }
        input:checked + .slider:before { transform: translateX(22px); }

        /* Modal Styles */
        .modal-overlay { position: fixed; inset: 0; background-color: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 1000; animation: fadeIn 0.3s; }
        .modal-content { background: #393939; color: #cccccc; padding: 1.5rem; border-radius: 1rem; max-width: 90vw; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .type-chart-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 0.5rem; }
        .type-chart-cell { text-align: center; padding: 0.5rem; border-radius: 0.5rem; }

        /* Ranking Podium */
        .podium { display: flex; justify-content: center; align-items: flex-end; gap: 1rem; min-height: 250px; }
        .podium-item { display: flex; flex-direction: column; align-items: center; text-align: center; }
        .podium-2 { order: 1; } .podium-1 { order: 2; } .podium-3 { order: 3; }
        .podium-img { border-radius: 50%; object-fit: cover; border: 4px solid; cursor: pointer; }
        .podium-1 .podium-img { width: 120px; height: 120px; border-color: #FFD700; }
        .podium-2 .podium-img { width: 100px; height: 100px; border-color: #C0C0C0; }
        .podium-3 .podium-img { width: 80px; height: 80px; border-color: #CD7F32; }
        .podium-base { color: white; font-weight: bold; padding: 0.5rem 1rem; border-radius: 0.5rem 0.5rem 0 0; }
        .podium-1 .podium-base { background-color: #FFD700; width: 100%; min-height: 100px; }
        .podium-2 .podium-base { background-color: #C0C0C0; width: 100%; min-height: 75px; }
        .podium-3 .podium-base { background-color: #CD7F32; width: 100%; min-height: 50px; }
        
    </style>
</head>
<body class="bg-[#2d2d2d] text-gray-300">
    <!-- Overlays and Loaders -->
    <div id="modal-container"></div>
    <div id="move-tooltip"></div>

    <!-- Navigation Bar -->
    <nav class="bg-gray-900 shadow-lg sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center">
                    <span class="font-title text-2xl text-[#9c9] cursor-pointer" id="home-btn">몬배틀 헌터즈</span>
                </div>
                <div id="nav-links" class="flex items-center gap-2 sm:gap-4"></div>
            </div>
        </div>
    </nav>

    <!-- Auth View -->
    <div id="auth-view" class="view">
        <div class="max-w-md mx-auto mt-10 p-8 bg-gray-800 rounded-lg shadow-lg">
            <h2 class="font-title text-3xl text-center text-white mb-4">소환사 합류</h2>
            <p class="text-center text-gray-400 mb-6">당신의 상상력으로 우주의 전설을 만드세요.</p>
            <div id="auth-tabs" class="flex border-b border-gray-700 mb-6">
                <button data-tab="login" class="tab-btn flex-1 py-2 font-bold text-gray-500 border-b-2 border-transparent">로그인</button>
                <button data-tab="signup" class="tab-btn flex-1 py-2 font-bold text-gray-500 border-b-2 border-transparent">회원가입</button>
            </div>
            <!-- Login Form -->
            <form id="login-form" class="auth-form space-y-4">
                <input type="email" id="login-email" placeholder="이메일" class="w-full p-3 border rounded-lg bg-gray-700 text-white border-gray-600" required>
                <input type="password" id="login-password" placeholder="비밀번호" class="w-full p-3 border rounded-lg bg-gray-700 text-white border-gray-600" required>
                <button type="submit" class="w-full bg-[#8abeb7] text-white font-bold py-3 rounded-lg hover:bg-[#6cc]">성소 입장</button>
                <a href="#" id="forgot-password-link" class="text-sm text-[#8abeb7] hover:underline text-center block mt-2">비밀번호를 잊으셨나요?</a>
            </form>
            <!-- Signup Form -->
            <form id="signup-form" class="auth-form space-y-4 hidden">
                <input type="email" id="signup-email" placeholder="이메일" class="w-full p-3 border rounded-lg bg-gray-700 text-white border-gray-600" required>
                <input type="password" id="signup-password" placeholder="비밀번호" class="w-full p-3 border rounded-lg bg-gray-700 text-white border-gray-600" required>
                <button type="submit" class="w-full bg-[#9c9] text-white font-bold py-3 rounded-lg hover:bg-[#7a7]">소환사 등록 (5 크레딧 지급)</button>
            </form>
            <p id="auth-error" class="text-red-400 text-center mt-4"></p>
        </div>
    </div>

    <!-- Main Pokedex View -->
    <div id="pokedex-view" class="view">
        <div id="pokedex-view-background"></div>
        <div class="max-w-7xl mx-auto p-2 sm:p-4">
            <header class="text-center my-4">
                <h1 class="font-title text-4xl md:text-5xl text-gray-100">몬배틀 헌터즈</h1>
                <p class="text-gray-400 mt-1 text-lg">당신의 상상력이 현실이 됩니다. 지금껏 없던 크리처를 소환하여 우주의 전설이 되세요.</p>
                 <div class="mt-3 flex justify-center flex-wrap gap-2">
                      <button id="go-to-battle-btn" class="bg-[#c99] text-white font-bold py-2 px-3 rounded-lg hover:bg-[#a77] transition-transform transform hover:scale-105 disabled:bg-gray-600 disabled:cursor-not-allowed text-sm">은하계 토너먼트</button>
                      <button id="go-to-ranking-btn" class="bg-[#f99157] text-white font-bold py-2 px-3 rounded-lg hover:bg-[#d76e2d] transition-transform transform hover:scale-105 text-sm">랭킹 보기</button>
                      <button id="show-type-chart-btn" class="bg-[#8abeb7] text-white font-bold py-2 px-3 rounded-lg hover:bg-[#6cc] transition-transform transform hover:scale-105 text-sm">상성표</button>
                      <button id="show-rarity-table-btn" class="bg-[#c9c] text-white font-bold py-2 px-3 rounded-lg hover:bg-[#a7a] transition-transform transform hover:scale-105 text-sm">등급표</button>
                 </div>
            </header>

            <!-- Ranking Podium -->
            <div id="ranking-podium-container" class="mb-6">
                <h2 class="font-title text-2xl text-center mb-2 text-gray-200">명예의 전당</h2>
                <div id="ranking-podium-view" class="podium"></div>
            </div>

            <div id="character-creation-section" class="bg-gray-800/80 backdrop-blur-sm p-4 rounded-2xl shadow-lg mb-4">
                <h3 class="font-title text-2xl text-center text-white mb-3">크리처 소환</h3>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
                    <select id="universe-select" class="p-2 border-2 rounded-lg focus:outline-none focus:ring-2 bg-gray-700 text-white border-gray-600 focus:ring-[#9c9]">
                        <option value="에테리얼">에테리얼 (에너지 종족)</option>
                        <option value="키티노이드">키티노이드 (곤충 종족)</option>
                        <option value="어비셜">어비셜 (심연 종족)</option>
                    </select>
                    <input type="text" id="character-prompt" class="md:col-span-2 p-2 border-2 rounded-lg focus:outline-none focus:ring-2 bg-gray-700 text-white border-gray-600 focus:ring-[#8abeb7]" placeholder="소환할 크리처의 특징을 상상해보세요 (예: 불타는 날개, 수정 갑옷)">
                </div>
                <div class="mt-3 flex justify-center items-center gap-4">
                    <button id="generate-btn" class="bg-[#8abeb7] text-white font-bold py-2 px-5 rounded-lg hover:bg-[#6cc] transition-transform transform hover:scale-105">
                        <span id="btn-text">세상에 없던 크리처 소환 (1 크레딧)</span>
                    </button>
                </div>
                <div id="error-message" class="text-yellow-400 mt-2 text-center text-sm font-semibold"></div>
            </div>
             <div id="filter-container" class="flex justify-center gap-2 mb-4">
                  <button class="filter-btn active" data-filter="all">전체</button>
                  <button class="filter-btn" data-filter="에테리얼">에테리얼</button>
                  <button class="filter-btn" data-filter="키티노이드">키티노이드</button>
                  <button class="filter-btn" data-filter="어비셜">어비셜</button>
             </div>
            <div id="pokedex-container" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4"></div>
            <div id="empty-state" class="text-center py-16 px-6 bg-gray-800 rounded-2xl shadow-lg hidden"><h3 class="mt-4 text-xl font-semibold text-gray-100">창조의 기록이 비어있습니다. 첫 크리처를 소환해보세요!</h3></div>
            <div id="pagination-controls" class="text-center mt-6"></div>
        </div>
    </div>
    
    <!-- Other Views (Containers) -->
    <div id="detail-view" class="view"></div>
    <div id="battle-selection-view" class="view"></div>
    <div id="battle-arena-view" class="view"></div>
    <div id="ranking-view" class="view"></div>
    <div id="profile-view" class="view"></div>
    <div id="admin-view" class="view"></div>

    <script type="module">
        // --- Supabase Client Setup ---
        const { createClient } = supabase;
        const SUPABASE_URL = 'https://byepyjdvhggofjjwsqna.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJ5ZXB5amR2aGdnb2ZqandzcW5hIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY0NjU0MjIsImV4cCI6MjA3MjA0MTQyMn0.NR1GJAm6aRYMpGZlKvfjfV2CVa2htqbtymZfmi1Owjs';
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // --- DOM Elements ---
        const views = document.querySelectorAll('.view');
        const modalContainer = document.getElementById('modal-container');
        const moveTooltip = document.getElementById('move-tooltip');
        const navLinks = document.getElementById('nav-links');
        const homeBtn = document.getElementById('home-btn');
        const authView = document.getElementById('auth-view');
        const tabBtns = document.querySelectorAll('.tab-btn');
        const loginForm = document.getElementById('login-form');
        const signupForm = document.getElementById('signup-form');
        const authError = document.getElementById('auth-error');
        const generateBtn = document.getElementById('generate-btn');
        const universeSelect = document.getElementById('universe-select');
        const promptInput = document.getElementById('character-prompt');
        const pokedexContainer = document.getElementById('pokedex-container');
        const emptyState = document.getElementById('empty-state');
        const errorMessage = document.getElementById('error-message');
        const btnText = document.getElementById('btn-text');
        const goToBattleBtn = document.getElementById('go-to-battle-btn');
        const goToRankingBtn = document.getElementById('go-to-ranking-btn');
        const showTypeChartBtn = document.getElementById('show-type-chart-btn');
        const showRarityTableBtn = document.getElementById('show-rarity-table-btn');
        const characterCreationSection = document.getElementById('character-creation-section');
        const detailViewContainer = document.getElementById('detail-view');
        const battleSelectionViewContainer = document.getElementById('battle-selection-view');
        const battleArenaContainer = document.getElementById('battle-arena-view');
        const rankingViewContainer = document.getElementById('ranking-view');
        const profileViewContainer = document.getElementById('profile-view');
        const adminViewContainer = document.getElementById('admin-view');
        const rankingPodiumView = document.getElementById('ranking-podium-view');
        const filterBtns = document.querySelectorAll('.filter-btn');
        const paginationControls = document.getElementById('pagination-controls');

        // --- App State & Data (Local Cache) ---
        let currentUser = null;
        let currentProfile = null;
        let allCharacters = [];
        let totalCharacterCount = 0;
        let currentPage = 0;
        const PAGE_SIZE = 12;
        let isLoadingMore = false;
        let allProfiles = [];
        let characterSubscription = null;
        let activeFilter = 'all';
        let isAutoBattleRunning = false;

        const battleBackgrounds = [
            'https://byepyjdvhggofjjwsqna.supabase.co/storage/v1/object/public/battle_images/arion_ground.webp',
            'https://byepyjdvhggofjjwsqna.supabase.co/storage/v1/object/public/battle_images/desert_ground.webp',
            'https://byepyjdvhggofjjwsqna.supabase.co/storage/v1/object/public/battle_images/ice_ground.webp',
            'https://byepyjdvhggofjjwsqna.supabase.co/storage/v1/object/public/battle_images/lasbsgas_gorund.webp',
            'https://byepyjdvhggofjjwsqna.supabase.co/storage/v1/object/public/battle_images/main_bg.webp'
        ];
        const typeChart = { Normal: { Rock: 0.5, Ghost: 0, Steel: 0.5 }, Fire: { Fire: 0.5, Water: 0.5, Grass: 2, Ice: 2, Bug: 2, Rock: 0.5, Dragon: 0.5, Steel: 2 }, Water: { Fire: 2, Water: 0.5, Grass: 0.5, Ground: 2, Rock: 2, Dragon: 0.5 }, Electric: { Water: 2, Electric: 0.5, Grass: 0.5, Ground: 0, Flying: 2, Dragon: 0.5 }, Grass: { Fire: 0.5, Water: 2, Grass: 0.5, Poison: 0.5, Ground: 2, Flying: 0.5, Bug: 0.5, Rock: 2, Dragon: 0.5, Steel: 0.5 }, Ice: { Fire: 0.5, Water: 0.5, Grass: 2, Ice: 0.5, Ground: 2, Flying: 2, Dragon: 2, Steel: 0.5 }, Fighting: { Normal: 2, Ice: 2, Poison: 0.5, Flying: 0.5, Psychic: 0.5, Bug: 0.5, Rock: 2, Ghost: 0, Darkness: 2, Steel: 2, Fairy: 0.5 }, Poison: { Grass: 2, Poison: 0.5, Ground: 0.5, Rock: 0.5, Ghost: 0.5, Steel: 0, Fairy: 2 }, Ground: { Fire: 2, Electric: 2, Grass: 0.5, Poison: 2, Flying: 0, Bug: 0.5, Rock: 2, Steel: 2 }, Flying: { Electric: 0.5, Grass: 2, Fighting: 2, Bug: 2, Rock: 0.5, Steel: 0.5 }, Psychic: { Fighting: 2, Poison: 2, Psychic: 0.5, Darkness: 0, Steel: 0.5 }, Bug: { Fire: 0.5, Grass: 2, Fighting: 0.5, Poison: 0.5, Flying: 0.5, Psychic: 2, Ghost: 0.5, Darkness: 2, Steel: 0.5, Fairy: 0.5 }, Rock: { Fire: 2, Ice: 2, Fighting: 0.5, Ground: 0.5, Flying: 2, Bug: 2, Steel: 0.5 }, Ghost: { Normal: 0, Psychic: 2, Ghost: 2, Darkness: 0.5, Light: 2 }, Dragon: { Dragon: 2, Steel: 0.5, Fairy: 0 }, Steel: { Fire: 0.5, Water: 0.5, Electric: 0.5, Ice: 2, Rock: 2, Steel: 0.5, Fairy: 2, Light: 0.5 }, Fairy: { Fighting: 2, Poison: 0.5, Dragon: 2, Darkness: 2, Steel: 0.5 }, Light: { Ghost: 2, Darkness: 2, Grass: 0.5, Steel: 0.5, Fire: 0.5 }, Darkness: { Psychic: 2, Ghost: 2, Light: 2, Fighting: 0.5, Fairy: 0.5 } };
        const typeTranslations = { Normal: '노말', Fire: '불꽃', Water: '물', Electric: '전기', Grass: '풀', Ice: '얼음', Fighting: '격투', Poison: '독', Ground: '땅', Flying: '비행', Psychic: '에스퍼', Bug: '벌레', Rock: '바위', Ghost: '고스트', Dragon: '드래곤', Darkness: '악', Steel: '강철', Fairy: '페어리', Light: '빛' };
        
        const UNIVERSE_PASSIVES = {
            '에테리얼': { id: 'PASSIVE_AETHERIAL', name: '에너지 과부하', text: 'HP가 가득 찬 상태로 턴을 마치면, 최대 HP의 10%만큼 보호막을 얻습니다.' },
            '키티노이드': { id: 'PASSIVE_CHITINOID', name: '적응형 갑피', text: '공격 받으면 방어 또는 특방이 1단계 상승합니다. (각 1회)' },
            '어비셜': { id: 'PASSIVE_ABYSSAL', name: '공허의 손아귀', text: '공격 시 15% 확률로 상대를 2턴간 [공허] 상태로 만들어, 회복과 버프를 막습니다.' }
        };

        const MASTER_SKILL_LIST = {
            'DMG_S': { type: 'damage', power: 50, accuracy: 100, pp: 35, category: 'Physical', text: '기본 위력의 공격' },
            'DMG_M': { type: 'damage', power: 90, accuracy: 100, pp: 15, category: 'Special', text: '강한 위력의 공격' },
            'DMG_L': { type: 'damage', power: 110, accuracy: 85, pp: 10, category: 'Physical', text: '강력하지만 명중률이 낮은 공격' },
            'DMG_XL': { type: 'damage', power: 130, accuracy: 90, pp: 5, category: 'Special', text: '매우 강력한 공격' },
            'DMG_PRIORITY': { type: 'damage', power: 40, accuracy: 100, pp: 30, priority: 1, category: 'Physical', text: '위력은 낮지만 반드시 선제공격' },
            'DMG_L_RECOIL': { type: 'damage', power: 120, accuracy: 100, pp: 10, recoil: 0.25, category: 'Physical', text: '강력한 공격. 준 데미지의 25%를 반동으로 받음' },
            'DMG_XL_CHARGE': { type: 'damage', power: 200, accuracy: 100, pp: 5, charge: 1, category: 'Special', text: '1턴간 힘을 모아 다음 턴에 초강력 공격' },
            'COMBO_STARTER': { type: 'damage', power: 40, accuracy: 100, pp: 20, combo: 'start', category: 'Physical', text: '콤보 시동기. 다음 턴 [피니셔] 위력 2.5배' },
            'COMBO_FINISHER': { type: 'damage', power: 60, accuracy: 100, pp: 20, combo: 'finish', category: 'Physical', text: '콤보 피니셔. [시동기] 다음에 사용하면 위력 2.5배' },
            'BUFF_ATK_1': { type: 'buff', stat: 'attack', amount: 1, accuracy: 100, pp: 30, text: '자신의 공격을 1단계 상승시킨다.' },
            'DEBUFF_DEF_1': { type: 'debuff', stat: 'defense', amount: -1, accuracy: 100, pp: 30, text: '상대의 방어를 1단계 하락시킨다.' },
            'BUFF_ALL_1': { type: 'buff', stat: 'all', amount: 1, accuracy: 100, pp: 15, text: '자신의 모든 능력치를 1단계 상승시킨다.' },
            'DEBUFF_SPEED_2': { type: 'debuff', stat: 'speed', amount: -2, accuracy: 90, pp: 20, text: '상대의 속도를 2단계 크게 하락시킨다.' },
            'STATUS_POISON': { type: 'status', effect: 'poison', chance: 0.9, accuracy: 90, pp: 20, text: '90% 확률로 상대를 [독] 상태로 만든다.' },
            'STATUS_PARALYSIS': { type: 'status', effect: 'paralysis', chance: 0.9, accuracy: 90, pp: 20, text: '90% 확률로 상대를 [마비] 상태로 만든다.' },
            'HEAL_M': { type: 'heal', power: 0.25, pp: 20, text: '자신 최대 HP의 25%를 회복한다.' },
            'SHIELD_BREAK': { type: 'damage', power: 70, accuracy: 100, pp: 15, effect: 'shield_break', category: 'Physical', text: '상대의 보호막을 파괴하고 데미지를 준다.' }
        };
        
        const MASTER_ABILITY_LIST = {
            'GUTS': { text: '상태 이상에 걸리면 공격이 1.5배 상승한다.' },
            'TECHNICIAN': { text: '위력 60 이하 기술의 위력이 1.5배가 된다.' },
            'REGENERATOR': { text: '매 턴이 끝날 때마다 최대 체력의 1/16을 회복한다.' },
            'ADAPTABILITY': { text: '자신과 같은 타입의 기술 위력이 2배가 된다. (기존 1.5배)' },
            'MAGIC_GUARD': { text: '독, 반동 데미지 등 공격 이외의 데미지를 받지 않는다.' }
        };

        // --- Sound Engine ---
        let synths = {};
        function setupAudio() {
            if (Tone.context.state !== 'running') { Tone.start(); }
            if (!synths.hit) {
                synths.hit = new Tone.MembraneSynth().toDestination();
                synths.crit = new Tone.MetalSynth({ frequency: 200, envelope: { attack: 0.001, decay: 0.1, release: 0.01 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination();
                synths.superEffective = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.2 } }).toDestination();
                synths.victory = new Tone.PolySynth(Tone.Synth).toDestination();
                synths.uiClick = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
            }
        }
        const playHitSound = () => synths.hit?.triggerAttackRelease("C2", "8n");
        const playCritSound = () => synths.crit?.triggerAttackRelease("C5", "16n");
        const playSuperEffectiveSound = () => synths.superEffective?.triggerAttackRelease("G5", "16n");
        const playVictorySound = () => synths.victory?.triggerAttackRelease(["C5", "E5", "G5", "C6"], "8n", Tone.now());
        const playUiClickSound = () => synths.uiClick?.triggerAttackRelease("C5", "16n");

        // --- Navigation & UI Helpers ---
        function navigateTo(viewId, ...args) {
            isAutoBattleRunning = false; // Stop auto battle on navigation
            views.forEach(v => v.classList.remove('active'));
            const targetView = document.getElementById(viewId);
            if (targetView) {
                targetView.classList.add('active');
                window.scrollTo(0, 0);
                const renderFunctionName = `render${viewId.charAt(0).toUpperCase() + viewId.slice(1).replace(/-./g, x=>x[1].toUpperCase())}`;
                if (window[renderFunctionName] && typeof window[renderFunctionName] === 'function') {
                    window[renderFunctionName](...args);
                }
            }
        }
        window.navigateTo = navigateTo;
        
        function setLoadingState(isLoading) {
            generateBtn.disabled = isLoading;
            btnText.textContent = isLoading ? '소환 중...' : '세상에 없던 크리처 소환 (1 크레딧)';
        }

        function showModal(title, content, onConfirm) {
            const modalHTML = `
                <div id="modal-overlay" class="modal-overlay">
                    <div class="modal-content w-full max-w-lg">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-2xl font-bold">${title}</h2>
                            <button id="close-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
                        </div>
                        <div id="modal-main-content" class="text-gray-300">${content}</div>
                        ${onConfirm ? '<div class="mt-6 flex justify-end gap-3"><button id="confirm-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg">확인</button><button id="cancel-btn" class="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">취소</button></div>' : ''}
                    </div>
                </div>
            `;
            modalContainer.innerHTML = modalHTML;
            document.getElementById('close-modal-btn').onclick = closeModal;
            const overlay = document.getElementById('modal-overlay');
            overlay.onclick = (e) => { if (e.target === overlay) closeModal(); };
            if (onConfirm) {
                document.getElementById('confirm-btn').onclick = () => { onConfirm(); closeModal(); };
                document.getElementById('cancel-btn').onclick = closeModal;
            }
        }

        function closeModal() { modalContainer.innerHTML = ''; }
        window.closeModal = closeModal;

        function showTypeChartModal() {
            let chartHtml = '<div class="type-chart-grid">';
            const types = Object.keys(typeTranslations);
            chartHtml += types.map(attacker => {
                let cellHtml = `<div class="type-chart-cell type-${attacker}"><strong>${typeTranslations[attacker]}</strong><div class="text-xs mt-1">`;
                const effectiveness = typeChart[attacker] || {};
                cellHtml += Object.keys(effectiveness).map(defender => {
                    const multiplier = effectiveness[defender];
                    const defenderKorean = typeTranslations[defender] || defender;
                    if (multiplier === 2) return ` <span class="font-bold text-green-300">${defenderKorean}(2x)</span>`;
                    if (multiplier === 0.5) return ` <span class="font-bold text-red-300">${defenderKorean}(0.5x)</span>`;
                    if (multiplier === 0) return ` <span class="font-bold text-gray-400">${defenderKorean}(0x)</span>`;
                    return '';
                }).join('');
                return cellHtml + '</div></div>';
            }).join('');
            chartHtml += '</div>';
            showModal('타입 상성표', chartHtml);
        }

        function showRarityModal() {
            const content = `
                <table class="w-full text-left text-gray-300">
                    <thead><tr class="bg-gray-700"><th class="p-2">등급</th><th class="p-2">총 능력치 (BST)</th><th class="p-2">확률</th></tr></thead>
                    <tbody>
                        <tr class="border-b border-gray-600"><td class="p-2"><span class="rarity-badge rarity-신화">신화</span></td><td class="p-2">780 ~</td><td class="p-2">5%</td></tr>
                        <tr class="border-b border-gray-600"><td class="p-2"><span class="rarity-badge rarity-고대">고대</span></td><td class="p-2">660 - 779</td><td class="p-2">10%</td></tr>
                        <tr class="border-b border-gray-600"><td class="p-2"><span class="rarity-badge rarity-전설">전설</span></td><td class="p-2">540 - 659</td><td class="p-2">15%</td></tr>
                        <tr class="border-b border-gray-600"><td class="p-2"><span class="rarity-badge rarity-에픽">에픽</span></td><td class="p-2">420 - 539</td><td class="p-2">20%</td></tr>
                        <tr class="border-b border-gray-600"><td class="p-2"><span class="rarity-badge rarity-희귀">희귀</span></td><td class="p-2">300 - 419</td><td class="p-2">25%</td></tr>
                        <tr><td class="p-2"><span class="rarity-badge rarity-일반">일반</span></td><td class="p-2">~ 299</td><td class="p-2">25%</td></tr>
                    </tbody>
                </table>
            `;
            showModal('크리처 등급표', content);
        }

        function updateUIBasedOnAuthState() {
            navLinks.innerHTML = '';
            if (currentUser && currentProfile) {
                const nickname = currentProfile.nickname || currentUser.email.split('@')[0];
                navLinks.innerHTML = `
                    <span class="font-bold text-sm sm:text-base text-gray-300 hidden md:inline">환영합니다, ${nickname}님!</span>
                    <span class="font-bold text-sm sm:text-base text-yellow-400">크레딧: ${currentProfile.credits}</span>
                    <button class="font-bold text-sm sm:text-base text-[#8abeb7] hover:underline p-2" id="profile-btn">소환사의 성소</button>
                    ${currentProfile.is_admin ? `<button id="admin-btn" class="font-bold text-sm sm:text-base text-[#c9c] hover:underline p-2">관리자</button>` : ''}
                    <button id="logout-btn" class="font-bold text-sm sm:text-base text-[#c99] hover:underline p-2">로그아웃</button>
                `;
                document.getElementById('profile-btn').onclick = () => navigateTo('profile-view', currentUser.id);
                if (currentProfile.is_admin) document.getElementById('admin-btn').onclick = () => navigateTo('admin-view');
                document.getElementById('logout-btn').onclick = handleLogout;
                characterCreationSection.style.display = 'block';
                goToBattleBtn.disabled = false;
            } else {
                navLinks.innerHTML = `<button id="login-signup-btn" class="font-bold text-[#8abeb7] hover:underline p-2">로그인 / 회원가입</button>`;
                document.getElementById('login-signup-btn').onclick = () => navigateTo('auth-view');
                characterCreationSection.style.display = 'none';
                goToBattleBtn.disabled = true;
            }
        }

        // --- Data Fetching & Realtime ---
        async function initialDataLoad() {
            try {
                const { data: profilesData, error: profilesError } = await supabaseClient.from('battle_profiles').select('*');
                if (profilesError) throw profilesError;
                allProfiles = profilesData;

                if (currentUser) {
                    currentProfile = allProfiles.find(p => p.id === currentUser.id);
                }
                
                allCharacters = [];
                currentPage = 0;
                await loadMoreCharacters();
                
                updateUIBasedOnAuthState();
                navigateTo('pokedex-view');

            } catch (error) {
                console.error("Error on initial data load:", error);
                showModal('데이터 로딩 오류', `<p>데이터를 불러오는 데 실패했습니다: ${error.message}</p><p>Supabase 데이터베이스의 RLS(보안 정책)이 올바르게 설정되었는지 확인해주세요.</p>`);
            }
        }

        function handleRealtimeChanges(payload) {
            console.log('Realtime change received:', payload);
            const { eventType, new: newRecord, old: oldRecord, table } = payload;
            let id = eventType === 'DELETE' ? oldRecord.id : newRecord.id;

            if (table === 'battle_characters') {
                const index = allCharacters.findIndex(c => c.id === id);

                if (eventType === 'INSERT') {
                    const newChar = { ...newRecord.data, id: newRecord.id, created_at: newRecord.created_at, creator_id: newRecord.creator_id, rank_points: newRecord.rank_points, level: newRecord.level, experience: newRecord.experience, universe: newRecord.universe, image_url: newRecord.image_url, profile: allProfiles.find(p => p.id === newRecord.creator_id) };
                    allCharacters.unshift(newChar);
                } else if (eventType === 'UPDATE') {
                    if (index > -1) {
                        const updatedCharacter = { ...newRecord.data, id: newRecord.id, created_at: newRecord.created_at, creator_id: newRecord.creator_id, rank_points: newRecord.rank_points, level: newRecord.level, experience: newRecord.experience, universe: newRecord.universe, image_url: newRecord.image_url, profile: allProfiles.find(p => p.id === newRecord.creator_id) };
                        allCharacters[index] = updatedCharacter;
                    }
                } else if (eventType === 'DELETE') {
                    if (index > -1) {
                        allCharacters.splice(index, 1);
                    }
                }
            } else if (table === 'battle_profiles') {
                const index = allProfiles.findIndex(p => p.id === id);
                if (eventType === 'INSERT' && index === -1) {
                    allProfiles.push(newRecord);
                } else if (eventType === 'UPDATE' && index > -1) {
                    allProfiles[index] = { ...allProfiles[index], ...newRecord };
                }
            }
            
            const activeView = document.querySelector('.view.active');
            if (activeView && activeView.id !== 'battle-arena-view') {
                const renderFunctionName = `render${activeView.id.charAt(0).toUpperCase() + activeView.id.slice(1).replace(/-./g, x=>x[1].toUpperCase())}`;
                 if (window[renderFunctionName] && typeof window[renderFunctionName] === 'function') {
                      const currentId = activeView.dataset.id;
                      window[renderFunctionName](currentId);
                 }
            }
            if (document.getElementById('pokedex-view').classList.contains('active')) {
                 renderPokedexView();
                 renderRankingPodium();
            }
            if (currentUser && currentProfile && id === currentUser.id) {
                currentProfile = allProfiles.find(p => p.id === currentUser.id);
                updateUIBasedOnAuthState();
            }
        }

        function subscribeToChanges() {
            if (characterSubscription) characterSubscription.unsubscribe();
            characterSubscription = supabaseClient.channel('hipoketmon-db-changes')
                .on('postgres_changes', { event: '*', schema: 'public' }, handleRealtimeChanges)
                .subscribe();
        }

        // --- Authentication & Prophecy ---
        async function generateSummonerProphecy(email) {
            const apiKey = "";
            const userIdentifier = email.split('@')[0];
            const prompt = `You are a wise oracle. A new summoner, known by the identifier '${userIdentifier}', has just arrived in the cosmos. Craft a short, epic, one or two-sentence prophecy for them in Korean. The prophecy should hint at a grand destiny involving summoning a powerful, unique creature, but remain mystical and vague. The tone should be inspiring and grand.`;

            const payload = { contents: [{ parts: [{ text: prompt }] }] };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            try {
                const result = await callApiWithRetry(apiUrl, payload);
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    return result.candidates[0].content.parts[0].text;
                }
                return "별들이 당신의 앞날을 속삭이지만, 아직은 그 뜻을 알 수 없습니다...";
            } catch (error) {
                console.error("Prophecy Generation Error:", error);
                return "운명의 실타래가 엉키었으니, 당신의 길은 스스로 개척해야 합니다...";
            }
        }
        
        async function listenToAuthStateChanges() {
            supabaseClient.auth.onAuthStateChange(async (_event, session) => {
                const wasSignedOut = !currentUser;
                currentUser = session?.user || null;
                
                if (currentUser) {
                    currentProfile = allProfiles.find(p => p.id === currentUser.id);
                    if (!currentProfile) { // Fetch profiles again if not found (e.g., after signup)
                        const { data } = await supabaseClient.from('battle_profiles').select('*');
                        if(data) allProfiles = data;
                        currentProfile = allProfiles.find(p => p.id === currentUser.id);
                    }
                } else {
                    currentProfile = null;
                }
                
                updateUIBasedOnAuthState();

                if (wasSignedOut && currentUser) {
                    navigateTo('pokedex-view');
                } else if (!currentUser) {
                     const protectedViews = ['profile-view', 'battle-selection-view', 'admin-view'];
                     const currentView = document.querySelector('.view.active')?.id || 'pokedex-view';
                     if (protectedViews.includes(currentView)) {
                         navigateTo('pokedex-view');
                     }
                }
            });
        }

        async function handleSignup(e) {
            e.preventDefault();
            const email = document.getElementById('signup-email').value;
            const password = document.getElementById('signup-password').value;
            const { error } = await supabaseClient.auth.signUp({ 
                email, 
                password,
                options: {
                    emailRedirectTo: 'https://07150906.vercel.app'
                }
            });
            if (error) {
                authError.textContent = `회원가입 오류: ${error.message}`;
            } else {
                authError.textContent = '';
                showModal(
                    '소환사 등록 확인', 
                    `<p>당신의 운명을 기록하는 중...</p><div class="text-center mt-4"><div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-gray-100"></div></div>`
                );
                const prophecy = await generateSummonerProphecy(email);
                const modalContentEl = document.getElementById('modal-main-content');
                if(modalContentEl) {
                    modalContentEl.innerHTML = `
                        <p><strong>${email}</strong>(으)로 확인 이메일을 보냈습니다. 링크를 클릭하여 당신의 존재를 증명해주세요.</p>
                        <div class="mt-4 p-4 border-l-4 border-yellow-400 bg-gray-800/50">
                            <p class="font-bold text-yellow-300">오라클의 예언:</p>
                            <p class="text-gray-300 italic">"${prophecy}"</p>
                        </div>
                    `;
                }
            }
        }

        async function handleLogin(e) {
            e.preventDefault();
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;
            const { error } = await supabaseClient.auth.signInWithPassword({ email, password });
            if (error) {
                authError.textContent = `로그인 오류: ${error.message}`;
            } else {
                authError.textContent = '';
                // The onAuthStateChange listener will handle navigation
            }
        }

        async function handleLogout() {
            await supabaseClient.auth.signOut();
        }
        
        // --- Character Generation ---
        function determineRarityAndBST() {
            const rarityData = [
                { rarity: '신화', bstRange: { min: 780, max: 850 }, weight: 5 },
                { rarity: '고대', bstRange: { min: 660, max: 779 }, weight: 10 },
                { rarity: '전설', bstRange: { min: 540, max: 659 }, weight: 15 },
                { rarity: '에픽', bstRange: { min: 420, max: 539 }, weight: 20 },
                { rarity: '희귀', bstRange: { min: 300, max: 419 }, weight: 25 },
                { rarity: '일반', bstRange: { min: 250, max: 299 }, weight: 25 },
            ];
            const rarityPool = rarityData.flatMap(r => Array(r.weight).fill(r));
            return rarityPool[Math.floor(Math.random() * rarityPool.length)];
        }

        async function generateCharacter() {
            if (!currentUser) { showModal('로그인 필요', '<p>크리처를 소환하려면 먼저 소환사로 등록해야 합니다.</p>'); navigateTo('auth-view'); return; }
            
            const { data: freshProfile, error: profileError } = await supabaseClient.from('battle_profiles').select('credits').eq('id', currentUser.id).single();
            if (profileError) { showModal('오류', `<p>프로필 정보를 불러오는 데 실패했습니다: ${profileError.message}</p>`); return; }
            currentProfile.credits = freshProfile.credits;
            updateUIBasedOnAuthState();

            if (currentProfile.credits < 1) { showModal('크레딧 부족', '<p>소환 에너지가 부족합니다. 매일 성소에서 출석하여 에너지를 보충하세요!</p>'); return; }
            
            const userPrompt = promptInput.value.trim();
            if (!userPrompt) { errorMessage.textContent = '소환할 크리처의 핵심 특징을 입력해주세요.'; return; }
            
            setLoadingState(true);
            errorMessage.textContent = '차원의 문을 여는 중... (최대 1분 소요)';
            
            try {
                const universe = universeSelect.value;
                const { rarity, bstRange } = determineRarityAndBST();
                const [pngImageUrlBase64, newCharData] = await Promise.all([ 
                    generateCharacterImage(userPrompt, universe), 
                    generateCharacterData(userPrompt, universe, rarity, bstRange) 
                ]);
                
                errorMessage.textContent = '이미지를 현실 세계에 고정하는 중...';
                const webpImageUrlBase64 = await convertImageToWebP(pngImageUrlBase64);

                errorMessage.textContent = '크리처를 창조의 기록에 새기는 중...';
                
                const imageBlob = base64ToBlob(webpImageUrlBase64, 'image/webp');
                const filePath = `${currentUser.id}/${Date.now()}.webp`;
                const { error: uploadError } = await supabaseClient.storage.from('battle_images').upload(filePath, imageBlob);
                if (uploadError) throw uploadError;

                const { data: { publicUrl } } = supabaseClient.storage.from('battle_images').getPublicUrl(filePath);
                
                const finalCharacterData = { ...newCharData, rarity };

                const { error: insertError } = await supabaseClient.from('battle_characters').insert({ 
                    creator_id: currentUser.id, 
                    image_url: publicUrl, 
                    data: finalCharacterData,
                    universe: universe
                });
                if (insertError) throw insertError;
                
                const { error: creditError } = await supabaseClient.from('battle_profiles').update({ credits: currentProfile.credits - 1 }).eq('id', currentUser.id);
                if (creditError) throw creditError;
                
                currentProfile.credits -= 1;
                updateUIBasedOnAuthState();

                promptInput.value = '';
                errorMessage.textContent = '';
                showModal('소환 성공!', `<p>새로운 크리처 <strong>${finalCharacterData.name}</strong>(${rarity})이(가) 당신의 부름에 응답했습니다!</p>`);
                
                allCharacters = [];
                currentPage = 0;
                await loadMoreCharacters();

            } catch (error) {
                console.error("Character Generation Error:", error);
                 let displayError = error.message;
                 if (error.message.includes("security policy")) {
                     displayError = `파일 저장소(Storage)의 보안 정책(RLS)이 설정되지 않았습니다. Supabase 대시보드에서 'battle_images' 버킷에 대한 SELECT, INSERT, DELETE 정책을 올바르게 설정해주세요.`;
                 }
                showModal('소환 실패', `<p>소환 중 차원의 틈에서 오류가 발생했습니다. 에너지는 소모되지 않았습니다. <br>오류: ${displayError}</p>`);
                errorMessage.textContent = `⚠️ 소환 중 오류가 발생했습니다.`;
            } finally {
                setLoadingState(false);
            }
        }
        
        async function callApiWithRetry(apiUrl, payload, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) {
                        if (response.status === 429) { await new Promise(res => setTimeout(res, delay * (i + 1))); continue; }
                        throw new Error(`API Error (${response.status}): ${await response.text()}`);
                    }
                    return response.json();
                } catch (error) {
                    if (i === retries - 1) throw error;
                    await new Promise(res => setTimeout(res, delay * (i + 1)));
                }
            }
        }
        
        async function generateCharacterImage(prompt, universe) {
            const apiKey = "";
            const universeStyleGuide = {
                "에테리얼": "ethereal cosmic creature, translucent body, glowing with internal light, swirling nebula patterns, celestial, made of pure energy, bioluminescent, astral",
                "키티노이드": "bio-mechanical insectoid warrior, chitinous armor, sharp mandibles, multiple glowing eyes, tough exoskeleton, predatory, beetle-like carapace",
                "어비셜": "lovecraftian horror from the void, shadowy tentacles, countless glowing eyes, amorphous, deep sea leviathan, abyssal terror, creature of darkness"
            };
            const stylePrompt = universeStyleGuide[universe] || "high-quality fantasy monster";
            const fullPrompt = `Full-body image of a unique creature, core concept: "${prompt}". Species: '${universe}' with their visual traits. Style: "${stylePrompt}". Clean white background.`;
            
            const payload = {
                contents: [{ parts: [{ text: fullPrompt }] }],
                generationConfig: { responseModalities: ['IMAGE'] }
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
            const result = await callApiWithRetry(apiUrl, payload);

            const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
            if (base64Data) {
                return `data:image/png;base64,${base64Data}`;
            }
            throw new Error("Image data was not returned from the API.");
        }

        async function generateCharacterData(prompt, universe, rarity, bstRange) {
            const apiKey = ""; 
            const skillListForPrompt = Object.entries(MASTER_SKILL_LIST).map(([id, skill]) => `- ${id} (${skill.category}, ${skill.pp}PP, ${skill.accuracy}Acc): ${skill.text}`).join('\n');
            const abilityListForPrompt = Object.entries(MASTER_ABILITY_LIST).map(([id, ability]) => `- ${id}: ${ability.text}`).join('\n');
            
            const basePrompt = `
**생성 규칙:**
1.  **등급/BST 준수:** "${rarity}" 등급, 총 능력치(BST)는 ${bstRange.min}~${bstRange.max} 사이.
2.  **기술/특성 선택:** 아래 목록에서 컨셉에 맞는 기술 ID 4개와 특성 ID 1개를 선택. **기술 4개 중 2개 이상은 반드시 'damage' 타입 스킬.**
3.  **창의적 이름 부여:** 선택한 기술/특성 ID에 컨셉에 맞는 멋진 한국어 이름을 새로 지어주세요.
4.  **능력치 분배:** 체력(HP)은 다른 스탯보다 4~6배 높게 설정.
5.  **타입 선택:** (${Object.keys(typeTranslations).join(', ')}) 중에서 2개를 선택.

**마스터 스킬 리스트:**
${skillListForPrompt}

**마스터 특성 리스트:**
${abilityListForPrompt}

**사용자 컨셉:** "${prompt}". 이 크리처는 '${universe}' 종족입니다. JSON 스키마에 맞춰 한국어로 답변해주세요.
`;
            const schema = {
                type: "OBJECT",
                properties: {
                    name: { type: "STRING" },
                    types: { type: "ARRAY", items: { type: "STRING" } },
                    ability: { type: "OBJECT", properties: { id: { type: "STRING" }, name: { type: "STRING" } } },
                    height: { type: "NUMBER" },
                    weight: { type: "NUMBER" },
                    pokedexEntry: { type: "STRING" },
                    stats: { type: "OBJECT", properties: { hp: { type: "INTEGER" }, attack: { type: "INTEGER" }, defense: { type: "INTEGER" }, sp_atk: { type: "INTEGER" }, sp_def: { type: "INTEGER" }, speed: { type: "INTEGER" } } },
                    moves: { type: "ARRAY", items: { type: "OBJECT", properties: { moveId: { type: "STRING" }, name: { type: "STRING" }, description: { type: "STRING" }, type: { type: "STRING" } } } }
                },
                required: ["name", "types", "ability", "pokedexEntry", "stats", "moves"]
            };
            const payload = { contents: [{ parts: [{ text: basePrompt }] }], generationConfig: { responseMimeType: "application/json", responseSchema: schema } };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const result = await callApiWithRetry(apiUrl, payload);
             if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                return JSON.parse(result.candidates[0].content.parts[0].text);
            }
            throw new Error("Character data generation failed or returned in an unexpected format.");
        }
        
        // --- Battle & Ranking Logic ---
        const statStageMultipliers = { '-6': 2/8, '-5': 2/7, '-4': 2/6, '-3': 2/5, '-2': 2/4, '-1': 2/3, '0': 1, '1': 3/2, '2': 4/2, '3': 5/2, '4': 6/2, '5': 7/2, '6': 8/2 };
        function getStatMultiplier(stage) { return statStageMultipliers[stage] || 1; }

        function calculateDamage(attacker, defender, move, turn) {
            const masterMove = (move.moveId === 'STRUGGLE') 
                ? { power: 50, accuracy: 100, category: 'Physical', type: 'damage' }
                : MASTER_SKILL_LIST[move.moveId] || {};
            
            if (Math.random() * 100 > masterMove.accuracy) return { damage: 0, isCritical: false, effectiveness: 1, missed: true };

            if (masterMove.type !== 'damage' || !masterMove.power) return { damage: 0, isCritical: false, effectiveness: 1 };
            
            let basePower = masterMove.power;
            if (attacker.battleStatus.ability?.id === 'TECHNICIAN' && basePower <= 60) basePower *= 1.5;
            if (attacker.battleStatus.comboReady && masterMove.combo === 'finish') basePower *= 2.5;

            const isPhysical = masterMove.category === 'Physical';
            let atkStat = isPhysical 
                ? attacker.stats.attack * getStatMultiplier(attacker.battleStatus.stat_stages.attack)
                : attacker.stats.sp_atk * getStatMultiplier(attacker.battleStatus.stat_stages.sp_atk);
            const defStat = isPhysical
                ? defender.stats.defense * getStatMultiplier(defender.battleStatus.stat_stages.defense)
                : defender.stats.sp_def * getStatMultiplier(defender.battleStatus.stat_stages.sp_def);

            if (attacker.battleStatus.ability?.id === 'GUTS' && attacker.battleStatus.status && isPhysical) atkStat *= 1.5;
            if (attacker.battleStatus.isDesperate) atkStat *= 1.25;

            let damage = (((2 * attacker.level / 5 + 2) * atkStat * basePower / defStat) / 50) * 1.4 + 2;
            
            let effectiveness = 1;
            if (move.moveId !== 'STRUGGLE') {
                defender.types.forEach(defType => {
                    const moveTypeKey = Object.keys(typeTranslations).find(key => typeTranslations[key] === move.type) || move.type;
                    effectiveness *= typeChart[moveTypeKey]?.[defType] ?? 1;
                });
            }

            let stab = 1;
            if (move.moveId !== 'STRUGGLE' && attacker.types.some(t => typeTranslations[t] === move.type)) {
                stab = attacker.battleStatus.ability?.id === 'ADAPTABILITY' ? 2 : 1.5;
            }
            damage *= effectiveness * stab;
            
            damage *= (1 + (turn - 1) * 0.05);

            const isCritical = Math.random() < (attacker.battleStatus.isDesperate ? 0.25 : 0.0625);
            if (isCritical) damage *= 1.5;
            
            let finalDamage = Math.floor(damage * (Math.random() * 0.15 + 0.85));

            return { damage: finalDamage, isCritical, effectiveness, missed: false };
        }

        async function updatePostBattleStats(winner, loser) {
            const K = 32;
            const winnerRank = winner.rank_points || 1000;
            const loserRank = loser.rank_points || 1000;
            const winnerExpected = 1 / (1 + 10 ** ((loserRank - winnerRank) / 400));
            const newWinnerRank = Math.round(winnerRank + K * (1 - winnerExpected));
            const newLoserRank = Math.max(0, Math.round(loserRank + K * (0 - (1 - winnerExpected))));
            
            const xpGained = 50 + (loser.level - winner.level) * 5;

            const updates = [
                supabaseClient.rpc('update_battle_record', { char_id: winner.id, is_win: true }),
                supabaseClient.rpc('update_battle_record', { char_id: loser.id, is_win: false }),
                supabaseClient.from('battle_characters').update({ rank_points: newWinnerRank }).eq('id', winner.id),
                supabaseClient.from('battle_characters').update({ rank_points: newLoserRank }).eq('id', loser.id)
            ];

            if (winner.creator_id === currentUser?.id) {
                 updates.push(supabaseClient.rpc('grant_experience_and_level_up', { char_id: winner.id, xp_to_add: Math.max(10, xpGained) }));
            }
            
            const results = await Promise.all(updates);
            
            // Check for errors in any of the promises
            for (const result of results) {
                if (result && result.error) {
                    throw new Error(`데이터베이스 업데이트 실패: ${result.error.message}`);
                }
            }

            return { newWinnerRank, newLoserRank };
        }
        
        // --- Helper Functions ---
        function base64ToBlob(base64, contentType = '', sliceSize = 512) {
            const byteCharacters = atob(base64.split(',')[1]);
            const byteArrays = [];
            for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
                const slice = byteCharacters.slice(offset, offset + sliceSize);
                const byteNumbers = new Array(slice.length);
                for (let i = 0; i < slice.length; i++) byteNumbers[i] = slice.charCodeAt(i);
                byteArrays.push(new Uint8Array(byteNumbers));
            }
            return new Blob(byteArrays, { type: contentType });
        }

        function convertImageToWebP(base64Png, quality = 0.8) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    canvas.getContext('2d').drawImage(img, 0, 0);
                    resolve(canvas.toDataURL('image/webp', quality));
                };
                img.onerror = (err) => reject(new Error("Failed to load image for WebP conversion."));
                img.src = base64Png;
            });
        }
        
        // --- Rendering Functions (Optimized) ---
        function createCharacterCard(char, variant = 'default', rank) {
            if (!char || !char.stats) {
                console.warn("Character with missing data, skipping card render:", char);
                return document.createDocumentFragment();
            }
            
            const bst = Object.values(char.stats).reduce((a, b) => a + b, 0);
            const creatorName = char.profile?.nickname || char.profile?.email?.split('@')[0] || 'Unknown';
            const imageUrl = `${char.image_url}?width=${variant === 'small' ? 128 : 320}&quality=80`;
            
            const card = document.createElement('div');
            card.className = `pokedex-card rounded-lg shadow-md p-4 card-border-${char.rarity}`;
            card.dataset.charId = char.id;
            
            if(variant === 'default') {
                const rankHTML = rank ? `<div class="absolute top-4 left-4 text-2xl font-black text-white/50" style="text-shadow: 1px 1px 2px #000;">#${rank}</div>` : '';
                card.innerHTML = `
                    <div class="flex flex-col sm:flex-row gap-4 relative">
                        ${rankHTML}
                        <div class="relative w-full sm:w-40 h-40 bg-gray-700 rounded-lg flex items-center justify-center flex-shrink-0">
                            <div class="level-display">LV.${char.level || 1}</div>
                            <img src="${imageUrl}" alt="${char.name}" class="absolute top-0 left-0 w-full h-full object-cover rounded-lg" loading="lazy" onerror="this.parentElement.innerHTML = '<span class=\'text-xs text-gray-400\'>Image Error</span>';">
                        </div>
                        <div class="flex-1">
                            <h3 class="font-bold text-xl">${char.name}</h3>
                            <div class="flex items-center gap-2 my-1">
                                <span class="rarity-badge rarity-${char.rarity}">${char.rarity}</span>
                                <span class="universe-badge universe-${char.universe}">${char.universe}</span>
                            </div>
                            <div class="flex gap-2 my-2">${char.types.map(t => `<span class="type-badge type-${t}">${typeTranslations[t] || t}</span>`).join('')}</div>
                            <p class="text-sm text-gray-400">소환사: <a href="#" data-profile-id="${char.creator_id}" class="text-[#8abeb7] hover:underline">${creatorName}</a></p>
                        </div>
                    </div>
                    <div class="mt-4">
                        <div class="text-xs font-bold text-gray-500 mb-1">능력치 (BST: ${bst})</div>
                        ${Object.entries(char.stats).map(([stat, value]) => `<div class="flex items-center gap-2 text-xs mb-1"><span class="w-12 font-semibold text-gray-400">${{hp:'HP', attack:'공격', defense:'방어', sp_atk:'특공', sp_def:'특방', speed:'속도'}[stat]}</span><div class="flex-1 stat-bar-bg"><div class="stat-bar h-2 bg-[#8abeb7]" style="width: ${Math.min(100, (value / (stat === 'hp' ? 300 : 150)) * 100)}%;"></div></div><span class="w-8 text-right font-bold">${value}</span></div>`).join('')}
                    </div>
                    <div class="rank-display">${char.rank_points || 'Unranked'} RP</div>
                `;
            } else if (variant === 'small') {
                 const record = char.record || { wins: 0, losses: 0 };
                 card.innerHTML = `
                    <div class="flex gap-4 items-center">
                        <div class="relative w-24 h-24 bg-gray-700 rounded-lg flex-shrink-0">
                             <div class="level-display" style="font-size: 0.7rem; padding: 1px 6px;">LV.${char.level || 1}</div>
                             <img src="${imageUrl}" alt="${char.name}" class="w-full h-full object-cover rounded-lg" loading="lazy">
                        </div>
                        <div class="flex-1 overflow-hidden">
                             <h3 class="font-bold text-lg truncate">${char.name}</h3>
                             <div class="flex items-center gap-1 my-1">
                                 <span class="rarity-badge rarity-${char.rarity}" style="font-size: 0.7rem; padding: 2px 8px;">${char.rarity}</span>
                                 <span class="universe-badge universe-${char.universe}">${char.universe}</span>
                             </div>
                             <div class="flex gap-1 my-1.5 flex-wrap">
                                 ${char.types.map(t => `<span class="type-badge type-${t}" style="font-size: 0.7rem; padding: 2px 8px;">${typeTranslations[t] || t}</span>`).join('')}
                             </div>
                             <p class="text-xs text-gray-400 truncate">랭크: ${char.rank_points || 1000} RP</p>
                             <p class="text-xs text-gray-400 truncate mt-0.5">전적: ${record.wins}승 ${record.losses}패</p>
                        </div>
                    </div>
                 `;
            }
            return card;
        }

        window.renderPokedexView = function() {
            renderRankingPodium();
            
            pokedexContainer.innerHTML = ''; 
            
            if (allCharacters.length === 0 && !isLoadingMore) {
                emptyState.style.display = 'block';
                pokedexContainer.style.display = 'none';
            } else {
                emptyState.style.display = 'none';
                pokedexContainer.style.display = 'grid';
                allCharacters.forEach(char => {
                    pokedexContainer.appendChild(createCharacterCard(char, 'default'));
                });
            }
            updatePaginationControls();
        };

        async function loadMoreCharacters() {
            if (isLoadingMore) return;
            isLoadingMore = true;

            const loadMoreBtn = document.getElementById('load-more-btn');
            if (loadMoreBtn) {
                loadMoreBtn.textContent = '불러오는 중...';
                loadMoreBtn.disabled = true;
            }

            const from = currentPage * PAGE_SIZE;
            const to = from + PAGE_SIZE - 1;

            let query = supabaseClient.from('battle_characters')
                .select('*, profile:battle_profiles(id, nickname, email)', { count: 'exact' })
                .order('created_at', { ascending: false })
                .range(from, to);
            
            if (activeFilter !== 'all') {
                query = query.eq('universe', activeFilter);
            }

            const { data, error, count } = await query;

            if (error) {
                console.error("Error fetching more characters:", error);
                showModal('오류', '크리처를 더 불러오는 데 실패했습니다.');
            } else {
                totalCharacterCount = count;
                const newCharacters = data.map(c => ({ ...c.data, id: c.id, created_at: c.created_at, creator_id: c.creator_id, rank_points: c.rank_points, image_url: c.image_url, level: c.level, experience: c.experience, universe: c.universe, profile: c.profile }));
                allCharacters.push(...newCharacters);
                currentPage++;
                renderPokedexView();
            }
            isLoadingMore = false;
        }

        function updatePaginationControls() {
            paginationControls.innerHTML = '';
            if (allCharacters.length < totalCharacterCount) {
                const loadMoreBtn = document.createElement('button');
                loadMoreBtn.id = 'load-more-btn';
                loadMoreBtn.className = 'bg-gray-700 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600';
                loadMoreBtn.textContent = '더 보기';
                paginationControls.appendChild(loadMoreBtn);
            }
        }
        
        window.renderDetailView = async function(characterId) {
            detailViewContainer.innerHTML = `<div class="text-center p-8"><h2 class="text-2xl font-bold">크리처 정보 로딩 중...</h2></div>`;
            const currentId = Number(characterId);
            detailViewContainer.dataset.id = currentId;
            
            let char = allCharacters.find(c => c.id === currentId);
            if (!char) {
                const { data, error } = await supabaseClient.from('battle_characters').select('*, profile:battle_profiles(id, nickname, email)').eq('id', currentId).single();
                if (error || !data) {
                    detailViewContainer.innerHTML = `<p class="text-center p-8">크리처를 찾을 수 없습니다.</p>`; return;
                }
                char = { ...data.data, id: data.id, created_at: data.created_at, creator_id: data.creator_id, rank_points: data.rank_points, image_url: data.image_url, profile: data.profile, level: data.level, experience: data.experience, universe: data.universe };
            }

            if (!char.stats) { detailViewContainer.innerHTML = `<p class="text-center p-8">크리처 데이터가 손상되었습니다.</p>`; return; }

            const [
                { data: comments, error: commentsError }, 
                { data: record, error: recordError }
            ] = await Promise.all([
                supabaseClient.from('battle_comments').select('*, profile:battle_profiles(id, nickname, email)').eq('character_id', currentId).order('created_at', { ascending: false }),
                supabaseClient.from('battle_records').select('wins, losses').eq('character_id', currentId).single()
            ]);

            const bst = Object.values(char.stats).reduce((a, b) => a + b, 0);
            const creatorName = char.profile?.nickname || char.profile?.email?.split('@')[0] || 'Unknown';
            const imageUrl = `${char.image_url}?width=512&quality=85`;
            const nextLevelXp = (char.level || 1) * 100;

            detailViewContainer.innerHTML = `
                <div class="max-w-4xl mx-auto p-4 sm:p-6 lg:p-8">
                    <div class="bg-gray-800 rounded-2xl shadow-xl overflow-hidden">
                        <div class="p-6 md:p-8">
                            <div class="flex flex-col md:flex-row gap-8">
                                <div class="md:w-1/3 text-center">
                                    <img src="${imageUrl}" alt="${char.name}" class="w-full h-auto object-cover rounded-lg shadow-lg mx-auto" onerror="this.onerror=null;this.src='https://placehold.co/256x256/e0e0e0/757575?text=Image+Not+Found';">
                                    ${(currentUser?.id === char.creator_id || currentProfile?.is_admin) ? `<button id="delete-char-btn" class="mt-4 bg-[#c99] text-white font-bold py-2 px-4 rounded-lg w-full">크리처 소멸</button>` : ''}
                                </div>
                                <div class="md:w-2/3">
                                    <h2 class="font-title text-4xl">${char.name} <span class="text-2xl text-gray-400">(${char.universe})</span></h2>
                                    <div class="flex items-center gap-2 my-2"><span class="rarity-badge rarity-${char.rarity}">${char.rarity}</span><span class="universe-badge universe-${char.universe}">${char.universe}</span></div>
                                    <div class="flex gap-2 my-3">${char.types.map(t => `<span class="type-badge type-${t}">${typeTranslations[t] || t}</span>`).join('')}</div>
                                    <p class="text-gray-300 my-4">${char.pokedexEntry}</p>
                                    <p class="text-sm text-gray-400">소환사: <a href="#" data-profile-id="${char.creator_id}" class="text-[#8abeb7] hover:underline">${creatorName}</a></p>
                                    <div class="grid grid-cols-2 gap-x-4 gap-y-1 text-sm mt-4">
                                        <span><b>키:</b> ${char.height || '?'}m</span>
                                        <span><b>몸무게:</b> ${char.weight || '?'}kg</span>
                                        <span><b title="${(MASTER_ABILITY_LIST[char.ability?.id] || {}).text || ''}">특성:</b> ${char.ability?.name || '미정'} ℹ️</span>
                                        <span><b title="${(UNIVERSE_PASSIVES[char.universe] || {}).text || ''}">종족 패시브:</b> ${(UNIVERSE_PASSIVES[char.universe] || {}).name || '없음'} ℹ️</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="bg-gray-700/50 p-6 md:p-8">
                            <h3 class="font-bold text-xl mb-4">레벨 및 랭킹 정보</h3>
                             <div class="mb-4">
                                 <div class="flex justify-between items-center text-sm font-bold mb-1">
                                     <span>LV. ${char.level || 1}</span>
                                     <span class="text-gray-400">${char.experience || 0} / ${nextLevelXp} XP</span>
                                 </div>
                                 <div class="w-full bg-gray-600 rounded-full h-2.5">
                                     <div class="bg-yellow-400 h-2.5 rounded-full" style="width: ${((char.experience || 0) / nextLevelXp) * 100}%"></div>
                                 </div>
                             </div>
                            <div class="flex items-center gap-4">
                                <span class="text-lg font-bold text-yellow-400">${char.rank_points || 1000} RP</span>
                                <span class="text-lg font-bold text-gray-300">${record ? `${record.wins}승 ${record.losses}패` : '전적 없음'}</span>
                            </div>
                        </div>
                        <div class="bg-gray-800 p-6 md:p-8">
                            <h3 class="font-bold text-xl mb-4">능력치 (총합: ${bst})</h3>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-2">
                                ${Object.entries(char.stats).map(([stat, value]) => `<div class="flex items-center gap-2 text-sm"><span class="w-16 font-semibold text-gray-400">${{hp:'HP', attack:'공격', defense:'방어', sp_atk:'특공', sp_def:'특방', speed:'속도'}[stat]}</span><div class="flex-1 stat-bar-bg"><div class="stat-bar h-3 bg-[#8abeb7]" style="width: ${Math.min(100, (value / (stat === 'hp' ? 300 : 150)) * 100)}%;"></div></div><span class="w-8 text-right font-bold">${value}</span></div>`).join('')}
                            </div>
                        </div>
                        <div class="bg-gray-700/50 p-6 md:p-8">
                            <h3 class="font-bold text-xl mb-4">기술</h3>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                ${char.moves.map(move => {
                                    const masterMove = MASTER_SKILL_LIST[move.moveId] || {};
                                    return `<div class="p-4 rounded-lg bg-gray-900/50 border border-gray-700">
                                        <p class="font-bold">${move.name} <span class="type-badge type-${Object.keys(typeTranslations).find(key => typeTranslations[key] === move.type) || move.type}">${move.type}</span></p>
                                        <p class="text-sm text-gray-400 mt-1">${move.description}</p>
                                        <div class="text-xs mt-2 grid grid-cols-2 gap-1 text-gray-300">
                                            <span><b>위력:</b> ${masterMove.power || '—'}</span>
                                            <span><b>분류:</b> ${masterMove.category || '기타'}</span>
                                            <span><b>명중률:</b> ${masterMove.accuracy || '—'}</span>
                                            <span><b>PP:</b> ${masterMove.pp || '—'}</span>
                                        </div>
                                    </div>`
                                }).join('')}
                            </div>
                        </div>
                        <div class="bg-gray-800 p-6 md:p-8">
                            <h3 class="font-bold text-xl mb-4">댓글</h3>
                            ${currentUser ? `<form id="comment-form" class="flex gap-2 mb-6"><input id="comment-input" type="text" placeholder="댓글을 입력하세요..." class="flex-1 p-2 border rounded-lg bg-gray-700 text-white border-gray-600" required><button type="submit" class="bg-[#8abeb7] text-white font-bold py-2 px-4 rounded-lg">등록</button></form>` : '<p class="text-center text-gray-500">댓글을 작성하려면 <a href="#" onclick="event.preventDefault(); navigateTo(\'auth-view\')" class="text-[#8abeb7] hover:underline">로그인</a>이 필요합니다.</p>'}
                            <div id="comments-container" class="space-y-4">${comments && comments.length > 0 ? comments.map(c => `<div class="flex gap-3"><div class="flex-1 bg-gray-900/50 p-3 rounded-lg border border-gray-700"><p class="text-sm">${c.content}</p><div class="text-xs text-gray-500 mt-2"><span>작성자: ${c.profile?.nickname || c.profile?.email?.split('@')[0]}</span><span class="mx-2">|</span><span>${new Date(c.created_at).toLocaleString()}</span></div></div>${(currentUser?.id === c.user_id || currentProfile?.is_admin) ? `<button data-comment-id="${c.id}" class="delete-comment-btn self-start text-red-500 hover:text-red-700 text-2xl">&times;</button>` : ''}</div>`).join('') : '<p class="text-center text-gray-500">아직 댓글이 없습니다.</p>'}</div>
                        </div>
                    </div>
                </div>
            `;
            
            detailViewContainer.querySelector('[data-profile-id]')?.addEventListener('click', (e) => { e.stopPropagation(); navigateTo('profile-view', e.target.dataset.profileId); });
            
            if (currentUser?.id === char.creator_id || currentProfile?.is_admin) {
                document.getElementById('delete-char-btn').onclick = () => {
                    showModal('크리처 소멸 확인', `<p><strong>${char.name}</strong>을(를) 정말로 소멸시키겠습니까? 이 작업은 되돌릴 수 없습니다.</p>`, async () => {
                         const { error: deleteStorageError } = await supabaseClient.storage.from('battle_images').remove([char.image_url.split('/').slice(-2).join('/')]);
                         if(deleteStorageError) console.error("Error deleting storage object:", deleteStorageError);
                        const { error } = await supabaseClient.from('battle_characters').delete().eq('id', char.id);
                        if (error) { showModal('삭제 오류', `<p>${error.message}</p>`); }
                        else { navigateTo('pokedex-view'); }
                    });
                };
            }

            if (currentUser) {
                document.getElementById('comment-form').onsubmit = async (e) => {
                    e.preventDefault();
                    const content = document.getElementById('comment-input').value;
                    if (!content.trim()) return;
                    const { error } = await supabaseClient.from('battle_comments').insert({ character_id: char.id, user_id: currentUser.id, content });
                    if (error) { showModal('댓글 등록 오류', `<p>${error.message}</p>`); }
                    else { document.getElementById('comment-input').value = ''; renderDetailView(characterId); }
                };
            }
            
            document.querySelectorAll('.delete-comment-btn').forEach(btn => {
                btn.onclick = () => {
                    showModal('댓글 삭제 확인', '<p>정말로 이 댓글을 삭제하시겠습니까?</p>', async () => {
                        const { error } = await supabaseClient.from('battle_comments').delete().eq('id', btn.dataset.commentId);
                        if (error) { showModal('삭제 오류', `<p>${error.message}</p>`); }
                        else { renderDetailView(characterId); }
                    });
                };
            });
        };

        window.renderBattleSelectionView = async function() {
            if (!currentUser) { navigateTo('auth-view'); return; }
            
            battleSelectionViewContainer.innerHTML = `<div class="text-center p-8"><h2 class="text-2xl font-bold">전투 목록 로딩 중...</h2></div>`;

            const [
                { data: allBattleCharsData, error: allCharsError },
                { data: recordsData, error: recordsError }
            ] = await Promise.all([
                supabaseClient.from('battle_characters').select('*, profile:battle_profiles(id, nickname, email)'),
                supabaseClient.from('battle_records').select('*')
            ]);
            
            if (allCharsError || recordsError) {
                showModal('오류', '배틀 데이터를 불러오는 데 실패했습니다.');
                battleSelectionViewContainer.innerHTML = ''; return;
            }
            
            const recordsMap = new Map(recordsData.map(r => [r.character_id, r]));
            const allBattleChars = allBattleCharsData.map(c => ({ ...c.data, id: c.id, creator_id: c.creator_id, rank_points: c.rank_points, image_url: c.image_url, universe: c.universe, profile: c.profile, level: c.level, record: recordsMap.get(c.id) }));

            const myCharacters = allBattleChars.filter(c => c.creator_id === currentUser.id);

            if (myCharacters.length === 0) {
                battleSelectionViewContainer.innerHTML = `<div class="text-center p-8 max-w-lg mx-auto bg-gray-800 rounded-lg shadow-md mt-10"><h2 class="text-2xl font-bold mb-4">소환한 크리처 없음</h2><p>토너먼트에 참여하려면 먼저 당신의 크리처를 소환해야 합니다.</p><button onclick="navigateTo('pokedex-view')" class="mt-4 bg-[#8abeb7] text-white font-bold py-2 px-4 rounded-lg">소환하러 가기</button></div>`;
                return;
            }

            battleSelectionViewContainer.innerHTML = `<div class="max-w-7xl mx-auto p-4"><h2 class="font-title text-3xl text-center mb-6">토너먼트에 내보낼 크리처 선택</h2><div id="player-char-list" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4"></div></div>`;
            const playerListContainer = document.getElementById('player-char-list');
            myCharacters.forEach(char => playerListContainer.appendChild(createCharacterCard(char, 'small')));

            playerListContainer.addEventListener('click', (e) => {
                e.stopPropagation(); // Stop the event from bubbling up to the body listener
                const card = e.target.closest('.pokedex-card');
                if (card && card.dataset.charId) {
                    selectOpponent(Number(card.dataset.charId));
                }
            });

            function selectOpponent(playerCharId) {
                const opponents = allBattleChars.filter(c => c.id !== playerCharId);
                
                if (opponents.length === 0) {
                    battleSelectionViewContainer.innerHTML = `<div class="text-center p-8 max-w-lg mx-auto bg-gray-800 rounded-lg shadow-md mt-10"><h2 class="text-2xl font-bold mb-4">상대 없음</h2><p>토너먼트에서 대결할 다른 크리처가 없습니다.</p><button onclick="navigateTo('pokedex-view')" class="mt-4 bg-[#8abeb7] text-white font-bold py-2 px-4 rounded-lg">메인으로</button></div>`;
                    return;
                }

                battleSelectionViewContainer.innerHTML = `<div class="max-w-7xl mx-auto p-4"><h2 class="font-title text-3xl text-center mb-6">상대할 크리처 선택</h2><div id="opponent-char-list" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4"></div></div>`;
                const opponentListContainer = document.getElementById('opponent-char-list');
                opponents.forEach(char => opponentListContainer.appendChild(createCharacterCard(char, 'small')));
                opponentListContainer.addEventListener('click', (e) => {
                    e.stopPropagation(); // Also stop this event from bubbling up
                    const card = e.target.closest('.pokedex-card');
                    if(card && card.dataset.charId) {
                        navigateTo('battle-arena-view', playerCharId, Number(card.dataset.charId));
                    }
                });
            }
        };

        window.renderBattleArenaView = async function(playerCharId, opponentCharId) {
             battleArenaContainer.innerHTML = `<div class="flex items-center justify-center h-full"><h2 class="text-2xl font-bold text-white">상대를 찾는 중...</h2></div>`;

             const [ { data: playerData, error: playerError }, { data: opponentData, error: opponentError } ] = await Promise.all([
                 supabaseClient.from('battle_characters').select('*, profile:battle_profiles(id, nickname, email, auto_battle_enabled)').eq('id', playerCharId).single(),
                 supabaseClient.from('battle_characters').select('*, profile:battle_profiles(id, nickname, email)').eq('id', opponentCharId).single()
             ]);

             if (playerError || opponentError || !playerData || !opponentData) {
                 showModal('배틀 오류', '배틀 상대를 불러오는 데 실패했습니다.');
                 navigateTo('battle-selection-view');
                 return;
             }

             const player = { ...playerData.data, id: playerData.id, ...playerData };
             const opponent = { ...opponentData.data, id: opponentData.id, ...opponentData };

             let turn = 1;
             let isProcessingTurn = false;
             isAutoBattleRunning = false;
             let battleLog = [];

             const initBattleState = (char) => ({
                 ...JSON.parse(JSON.stringify(char)),
                 battleStatus: {
                     currentHp: char.stats.hp,
                     maxHp: char.stats.hp,
                     status: null,
                     stat_stages: { attack: 0, defense: 0, sp_atk: 0, sp_def: 0, speed: 0 },
                     isDesperate: false,
                     comboReady: false,
                     ability: MASTER_ABILITY_LIST[char.ability?.id] ? { ...MASTER_ABILITY_LIST[char.ability?.id], id: char.ability.id } : null,
                     currentPP: Object.fromEntries(char.moves.map(m => [m.moveId, MASTER_SKILL_LIST[m.moveId]?.pp || 5]))
                 }
             });

             let playerState = initBattleState(player);
             let opponentState = initBattleState(opponent);

             const randomBg = battleBackgrounds[Math.floor(Math.random() * battleBackgrounds.length)];

             battleArenaContainer.innerHTML = `
                <div id="battle-background" style="background-image: url('${randomBg}')"></div>
                <div class="battle-ui-overlay">
                    <div class="characters-area">
                        <div class="opponent-container">
                             <img id="opponent-sprite" src="${opponentState.image_url}?width=384&quality=80" class="battle-character-sprite">
                             <div id="opponent-char-ui" class="battle-character-ui bg-gray-900/80 p-2 rounded-lg border border-gray-700"></div>
                         </div>
                         <div class="player-container">
                             <img id="player-sprite" src="${playerState.image_url}?width=384&quality=80" class="battle-character-sprite">
                              <div id="player-char-ui" class="battle-character-ui bg-gray-900/80 p-2 rounded-lg border border-gray-700"></div>
                         </div>
                    </div>
                    <div class="controls-area grid grid-cols-1 md:grid-cols-3 gap-4 bg-black/50 p-3 rounded-lg border border-gray-700 mt-2">
                         <div id="battle-log-container" class="md:col-span-1 h-32 overflow-y-auto bg-black/50 p-2 rounded text-sm text-gray-300"></div>
                         <div class="md:col-span-2 grid grid-cols-1 sm:grid-cols-[1fr_auto] gap-2 items-center">
                             <div id="player-moves" class="battle-moves-grid"></div>
                             <div class="flex flex-col gap-2">
                                <label class="flex items-center justify-center gap-2 text-sm font-bold"><input type="checkbox" id="auto-battle-checkbox" class="w-4 h-4">자동 전투</label>
                                <button id="forfeit-btn" class="bg-red-700 text-white font-bold p-2 rounded text-sm hover:bg-red-800">항복</button>
                             </div>
                         </div>
                     </div>
                 </div>
             `;
             
             const dom = {
                playerSprite: document.getElementById('player-sprite'),
                opponentSprite: document.getElementById('opponent-sprite'),
                playerUI: document.getElementById('player-char-ui'),
                opponentUI: document.getElementById('opponent-char-ui'),
                battleLog: document.getElementById('battle-log-container'),
                movesContainer: document.getElementById('player-moves'),
                autoBattleCheckbox: document.getElementById('auto-battle-checkbox'),
                forfeitBtn: document.getElementById('forfeit-btn')
             };
             
             function updateUI() {
                const renderCharUI = (charState, el) => {
                    const hpPercent = (charState.battleStatus.currentHp / charState.battleStatus.maxHp) * 100;
                    el.innerHTML = `
                        <div class="flex justify-between items-center font-bold text-sm">
                            <span>${charState.name} <span class="text-gray-400">Lv.${charState.level || 1}</span></span>
                            <span>HP: ${charState.battleStatus.currentHp} / ${charState.battleStatus.maxHp}</span>
                        </div>
                        <div class="w-full bg-gray-600 rounded-full h-4 mt-1 border border-black/50">
                            <div class="hp-bar-inner h-full rounded-full ${hpPercent > 50 ? 'bg-green-500' : hpPercent > 20 ? 'bg-yellow-500' : 'bg-red-500'}" style="width: ${hpPercent}%"></div>
                        </div>
                    `;
                };
                renderCharUI(playerState, dom.playerUI);
                renderCharUI(opponentState, dom.opponentUI);

                const hasUsableMoves = playerState.moves.some(m => playerState.battleStatus.currentPP[m.moveId] > 0);

                if (!hasUsableMoves) {
                    dom.movesContainer.innerHTML = `<button class="battle-move-item col-span-2" data-move-id="STRUGGLE">발버둥</button>`;
                } else {
                     dom.movesContainer.innerHTML = playerState.moves.map(move => {
                        const masterMove = MASTER_SKILL_LIST[move.moveId] || {};
                        const currentPP = playerState.battleStatus.currentPP[move.moveId];
                        const disabled = isProcessingTurn || currentPP <= 0;
                        return `<button class="battle-move-item" data-move-id="${move.moveId}" ${disabled ? 'disabled' : ''}>${move.name} <span class="pp-display">${currentPP}/${masterMove.pp || 5}</span></button>`;
                    }).join('');
                }

                dom.battleLog.innerHTML = battleLog.slice(-5).join('<br>');
                dom.battleLog.scrollTop = dom.battleLog.scrollHeight;
             }

             const addToLog = (msg) => { battleLog.push(msg); updateUI(); };

             async function handleBattleEnd(winner, loser) {
                isProcessingTurn = true;
                isAutoBattleRunning = false;
                
                try {
                    const winnerInitialRank = winner.rank_points || 1000;
                    const loserInitialRank = loser.rank_points || 1000;
                    const result = await updatePostBattleStats(winner, loser);
                    playVictorySound();

                    showModal('토너먼트 종료!', `
                        <div class="text-center">
                            <h3 class="text-3xl font-bold ${winner.id === playerState.id ? 'text-green-400' : 'text-red-400'}">${winner.id === playerState.id ? '승리!' : '패배...'}</h3>
                            <p class="mt-4"><strong>${winner.name}</strong> (이)가 <strong>${loser.name}</strong> (을)를 이겼습니다.</p>
                            ${winner.id === playerState.id ? `<p>XP +${Math.max(10, 50 + (loser.level - winner.level) * 5)}</p>` : ''}
                            <div class="mt-2 bg-gray-700/50 p-3 rounded-lg text-sm">
                                <p>승자: ${winner.name} | ${result.newWinnerRank} RP <span class="font-bold text-green-400">(+${result.newWinnerRank - winnerInitialRank})</span></p>
                                <p>패자: ${loser.name} | ${result.newLoserRank} RP <span class="font-bold text-red-400">(${result.newLoserRank - loserInitialRank})</span></p>
                            </div>
                            <button id="close-battle-results" class="mt-6 bg-[#8abeb7] text-white font-bold py-2 px-6 rounded-lg">확인</button>
                        </div>
                    `);
                    document.getElementById('close-battle-results').onclick = () => { closeModal(); initialDataLoad(); };
                } catch (error) {
                    console.error("전투 결과 저장 실패:", error);
                    showModal(
                        '오류 발생', 
                        `<p>전투 결과를 서버에 저장하는 중 문제가 발생했습니다. 랭크 포인트와 경험치가 제대로 반영되지 않았을 수 있습니다.</p><p class="mt-2 text-sm text-gray-400">오류: ${error.message}</p>`,
                        null
                    );
                    const modalContent = modalContainer.querySelector('.modal-content');
                    const closeButton = document.createElement('button');
                    closeButton.textContent = '메인으로 돌아가기';
                    closeButton.className = 'mt-6 bg-gray-600 text-white font-bold py-2 px-4 rounded-lg';
                    closeButton.onclick = () => { closeModal(); navigateTo('pokedex-view'); };
                    modalContent.appendChild(closeButton);
                }
             }

            function opponentAiSelectMove(attacker, defender) {
                const availableMoves = attacker.moves
                    .map(move => ({ ...move, master: MASTER_SKILL_LIST[move.moveId] }))
                    .filter(move => attacker.battleStatus.currentPP[move.moveId] > 0 && move.master);

                if (availableMoves.length === 0) return { moveId: 'STRUGGLE', name: '발버둥' };

                let bestMove = null;
                let maxDamage = -1;

                for (const move of availableMoves) {
                    if (move.master.type === 'damage') {
                        const { damage } = calculateDamage(attacker, defender, move, turn);
                        if (damage >= defender.battleStatus.currentHp) {
                            return attacker.moves.find(m => m.moveId === move.moveId);
                        }
                    }
                }

                for (const move of availableMoves) {
                     if (move.master.type === 'damage') {
                        const { damage } = calculateDamage(attacker, defender, move, turn);
                        if (damage > maxDamage) {
                            maxDamage = damage;
                            bestMove = move;
                        }
                    }
                }
                
                if (bestMove) {
                    return attacker.moves.find(m => m.moveId === bestMove.moveId);
                }

                return attacker.moves.find(m => m.moveId === availableMoves[Math.floor(Math.random() * availableMoves.length)].moveId);
            }


             async function executeTurn(playerMoveId) {
                if(isProcessingTurn) return;
                isProcessingTurn = true;
                
                const playerMove = playerState.moves.find(m => m.moveId === playerMoveId) || { moveId: 'STRUGGLE', name: '발버둥' };
                if(playerMove.moveId !== 'STRUGGLE') playerState.battleStatus.currentPP[playerMoveId]--;

                const opponentMove = opponentAiSelectMove(opponentState, playerState);
                if(opponentMove && opponentMove.moveId !== 'STRUGGLE') opponentState.battleStatus.currentPP[opponentMove.moveId]--;

                updateUI();
                await new Promise(res => setTimeout(res, 500));

                const playerSpeed = playerState.stats.speed * getStatMultiplier(playerState.battleStatus.stat_stages.speed);
                const opponentSpeed = opponentState.stats.speed * getStatMultiplier(opponentState.battleStatus.stat_stages.speed);
                
                let firstAttacker, secondAttacker, firstMove, secondMove;
                const playerMovePrio = MASTER_SKILL_LIST[playerMove.moveId]?.priority || 0;
                const opponentMovePrio = opponentMove ? MASTER_SKILL_LIST[opponentMove.moveId]?.priority || 0 : -1;
                
                if (playerMovePrio > opponentMovePrio || (playerMovePrio === opponentMovePrio && playerSpeed >= opponentSpeed)) {
                    [firstAttacker, secondAttacker, firstMove, secondMove] = [playerState, opponentState, playerMove, opponentMove];
                } else {
                    [firstAttacker, secondAttacker, firstMove, secondMove] = [opponentState, playerState, opponentMove, playerMove];
                }

                const processAttack = async (attacker, defender, move) => {
                     if (!move) return false;
                     const attackerSprite = (attacker.id === playerState.id) ? dom.playerSprite : dom.opponentSprite;
                     const defenderSprite = (defender.id === playerState.id) ? dom.playerSprite : dom.opponentSprite;
                     
                     addToLog(`${attacker.name}의 ${move.name} 공격!`);
                     
                     anime({ targets: attackerSprite, translateX: [0, (attacker.id === playerState.id ? 20 : -20), 0], duration: 400, easing: 'easeInOutSine' });
                     await new Promise(res => setTimeout(res, 400));
                     
                     const result = calculateDamage(attacker, defender, move, turn);
                     
                     if (result.missed) {
                         addToLog('...하지만 빗나갔다!');
                     } else {
                         defender.battleStatus.currentHp = Math.max(0, defender.battleStatus.currentHp - result.damage);
                         let effectivenessText = '';
                         if(result.effectiveness > 1) { effectivenessText = '효과는 굉장했다!'; playSuperEffectiveSound(); }
                         else if(result.effectiveness < 1 && result.effectiveness > 0) effectivenessText = '효과가 별로인 듯하다...';
                         else if(result.effectiveness === 0) effectivenessText = '효과가 없는 것 같다...';
                         if(result.isCritical) { effectivenessText += ' 급소에 맞았다!'; playCritSound(); }
                         
                         anime({ targets: defenderSprite, translateX: [0, (Math.random() - 0.5) * 10, 0], translateY: [0, (Math.random() - 0.5) * 10, 0], duration: 100, easing: 'linear', direction: 'alternate', loop: 2 });
                         playHitSound();
                         
                         addToLog(`${result.damage}의 데미지! ${effectivenessText}`);

                         if(move.moveId === 'STRUGGLE') {
                             const recoilDamage = Math.floor(attacker.battleStatus.maxHp / 4);
                             attacker.battleStatus.currentHp = Math.max(0, attacker.battleStatus.currentHp - recoilDamage);
                             addToLog(`${attacker.name}은(는) 반동으로 데미지를 입었다!`);
                             if (attacker.battleStatus.currentHp <= 0) {
                                 updateUI();
                                 await new Promise(res => setTimeout(res, 1000));
                                 return 'attacker_fainted';
                             }
                         }
                     }
                     updateUI();
                     await new Promise(res => setTimeout(res, 1000));
                     return defender.battleStatus.currentHp <= 0 ? 'defender_fainted' : false;
                };

                const firstAttackResult = await processAttack(firstAttacker, secondAttacker, firstMove);
                if (firstAttackResult === 'defender_fainted') {
                    addToLog(`${secondAttacker.name}은(는) 쓰러졌다!`);
                    await handleBattleEnd(firstAttacker, secondAttacker);
                    return;
                } else if (firstAttackResult === 'attacker_fainted') {
                     addToLog(`${firstAttacker.name}은(는) 쓰러졌다!`);
                     await handleBattleEnd(secondAttacker, firstAttacker);
                     return;
                }

                if (secondMove) {
                     const secondAttackResult = await processAttack(secondAttacker, firstAttacker, secondMove);
                     if (secondAttackResult === 'defender_fainted') {
                        addToLog(`${firstAttacker.name}은(는) 쓰러졌다!`);
                        await handleBattleEnd(secondAttacker, firstAttacker);
                        return;
                    } else if (secondAttackResult === 'attacker_fainted') {
                        addToLog(`${secondAttacker.name}은(는) 쓰러졌다!`);
                        await handleBattleEnd(firstAttacker, secondAttacker);
                        return;
                    }
                }
                
                isProcessingTurn = false;
                turn++;
                updateUI();

                if(isAutoBattleRunning) {
                    setTimeout(autoBattleLoop, 1500);
                }
             }
             
            function autoBattleLoop() {
                if (!isAutoBattleRunning || isProcessingTurn) return;

                const hasUsableMoves = playerState.moves.some(m => playerState.battleStatus.currentPP[m.moveId] > 0);
                if (!hasUsableMoves) {
                    executeTurn('STRUGGLE');
                    return;
                }
                
                const bestMove = opponentAiSelectMove(playerState, opponentState);
                executeTurn(bestMove.moveId);
            }
             
             dom.movesContainer.addEventListener('click', (e) => {
                 const moveBtn = e.target.closest('.battle-move-item');
                 if (moveBtn && !moveBtn.disabled) executeTurn(moveBtn.dataset.moveId);
             });

            dom.movesContainer.addEventListener('mouseover', (e) => {
                const moveBtn = e.target.closest('.battle-move-item');
                if (!moveBtn) return;
                const moveId = moveBtn.dataset.moveId;
                if (moveId === 'STRUGGLE') return;
                const moveData = playerState.moves.find(m => m.moveId === moveId);
                const masterMove = MASTER_SKILL_LIST[moveId] || {};
                
                moveTooltip.style.opacity = '1';
                moveTooltip.style.transform = 'translateY(0)';
                moveTooltip.innerHTML = `
                    <div class="font-bold flex justify-between items-center">
                        <span>${moveData.name}</span>
                        <span class="type-badge type-${Object.keys(typeTranslations).find(key => typeTranslations[key] === moveData.type) || moveData.type}">${moveData.type}</span>
                    </div>
                    <p class="text-sm text-gray-400 my-2">${moveData.description}</p>
                    <div class="grid grid-cols-2 gap-1 text-xs">
                        <span><b>분류:</b> ${masterMove.category || '기타'}</span>
                        <span><b>위력:</b> ${masterMove.power || '—'}</span>
                        <span><b>명중:</b> ${masterMove.accuracy || '—'}</span>
                        <span><b>PP:</b> ${playerState.battleStatus.currentPP[moveId]}/${masterMove.pp}</span>
                    </div>
                `;
                const rect = moveBtn.getBoundingClientRect();
                moveTooltip.style.left = `${rect.left}px`;
                moveTooltip.style.top = `${rect.top - moveTooltip.offsetHeight - 10}px`;
            });
             dom.movesContainer.addEventListener('mouseout', () => {
                 moveTooltip.style.opacity = '0';
                 moveTooltip.style.transform = 'translateY(10px)';
             });
             
             dom.autoBattleCheckbox.onchange = (e) => {
                 isAutoBattleRunning = e.target.checked;
                 if(isAutoBattleRunning) autoBattleLoop();
             };

            dom.autoBattleCheckbox.checked = player.profile?.auto_battle_enabled || false;
            if (dom.autoBattleCheckbox.checked) {
                isAutoBattleRunning = true;
                setTimeout(autoBattleLoop, 1500);
            }

             dom.forfeitBtn.onclick = () => {
                 showModal('항복 확인', '<p>정말로 토너먼트를 포기하시겠습니까?</p>', () => {
                    addToLog(`${playerState.name}이(가) 항복했습니다...`);
                    handleBattleEnd(opponentState, playerState);
                 });
             };

             addToLog(`은하계 토너먼트 시작! ${playerState.name} vs ${opponentState.name}`);
             updateUI();
        };

        window.renderRankingView = async function() {
            rankingViewContainer.innerHTML = `<div class="text-center p-8"><h2 class="text-2xl font-bold">랭킹 로딩 중...</h2></div>`;
            const { data, error } = await supabaseClient.from('battle_characters')
                .select('*, profile:battle_profiles(id, nickname, email)')
                .order('rank_points', { ascending: false });

            if (error) {
                rankingViewContainer.innerHTML = `<p class="text-center p-8">랭킹을 불러오는 데 실패했습니다.</p>`;
                return;
            }
            const sorted = data.map(c => ({ ...c.data, id: c.id, creator_id: c.creator_id, rank_points: c.rank_points, image_url: c.image_url, profile: c.profile, level: c.level, experience: c.experience, universe: c.universe }));
            rankingViewContainer.innerHTML = `
                <div class="max-w-4xl mx-auto p-4">
                    <h2 class="font-title text-4xl text-center mb-8">전체 랭킹</h2>
                    <div id="ranking-list" class="space-y-4"></div>
                </div>
            `;
            const listContainer = document.getElementById('ranking-list');
            sorted.forEach((char, index) => listContainer.appendChild(createCharacterCard(char, 'default', index + 1)));
        };

        window.renderProfileView = async function(profileId) {
            profileViewContainer.innerHTML = `<div class="text-center p-8"><h2 class="text-2xl font-bold">프로필 로딩 중...</h2></div>`;
            const profile = allProfiles.find(p => p.id === profileId);
            if (!profile) { profileViewContainer.innerHTML = `<p class="text-center p-8">프로필을 찾을 수 없습니다.</p>`; return; }
            
            const { data: userCharsData, error } = await supabaseClient.from('battle_characters')
                .select('*, profile:battle_profiles(id, nickname, email)')
                .eq('creator_id', profileId)
                .order('rank_points', { ascending: false });
            
            if (error) {
                profileViewContainer.innerHTML = `<p class="text-center p-8">캐릭터 목록을 불러오는 데 실패했습니다.</p>`;
                return;
            }
            
            const userCharacters = userCharsData.map(c => ({ ...c.data, id: c.id, created_at: c.created_at, creator_id: c.creator_id, rank_points: c.rank_points, image_url: c.image_url, profile: c.profile, level: c.level, experience: c.experience, universe: c.universe }));
            const isMyProfile = currentUser?.id === profileId;

            profileViewContainer.innerHTML = `
                <div class="max-w-4xl mx-auto p-4">
                    <div class="bg-gray-800 p-6 rounded-lg shadow-md mb-6">
                        <h2 class="text-2xl font-bold mb-4">소환사의 성소</h2>
                        <div class="space-y-4">
                            <div class="text-center mb-4">
                                <p class="text-lg text-gray-400">칭호</p>
                                <p class="text-2xl font-bold text-yellow-300" style="text-shadow: 0 0 5px #fde047;">💎 제네시스 소환사 💎</p>
                            </div>
                            <div><span class="font-semibold">이메일:</span> ${profile.email}</div>
                            <div class="flex items-center gap-2"><span class="font-semibold">닉네임:</span> <span id="nickname-display">${profile.nickname || '미설정'}</span> ${isMyProfile ? `<button id="edit-nickname-btn" class="text-sm text-[#8abeb7]">변경</button>` : ''}</div>
                            <div id="nickname-edit-form" class="hidden"><input type="text" id="nickname-input" value="${profile.nickname || ''}" class="p-1 border rounded bg-gray-700 border-gray-600"><button id="save-nickname-btn" class="ml-2 bg-green-500 text-white px-2 py-1 rounded">저장</button></div>
                            <div><span class="font-semibold">보유 크레딧:</span> ${isMyProfile ? currentProfile.credits : '비공개'}</div>
                            ${isMyProfile ? `
                                <div class="flex items-center gap-4">
                                    <span class="font-semibold">자동 전투 기본 설정</span>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="auto-battle-toggle" ${currentProfile.auto_battle_enabled ? 'checked' : ''}>
                                        <span class="slider"></span>
                                    </label>
                                </div>
                                <div class="bg-gray-700/50 p-4 rounded-lg">
                                    <h3 class="font-semibold mb-2">이메일 주소 변경</h3>
                                    <form id="change-email-form" class="flex gap-2">
                                        <input type="email" id="new-email-input" class="flex-1 p-2 border rounded-lg bg-gray-700 text-white border-gray-600" placeholder="새 이메일 주소" required>
                                        <button type="submit" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">인증메일 발송</button>
                                    </form>
                                </div>
                                <button id="check-in-btn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg w-full">출석 체크 (1 크레딧 획득)</button>
                            ` : ''}
                             <div class="text-center p-4 border border-dashed border-gray-600 rounded-lg mt-4">
                                <p class="text-gray-500 font-bold">소환사 의회</p>
                                <p class="text-sm text-gray-600">랭킹 100위 이내 달성 시 초대됩니다. (출시 예정)</p>
                            </div>
                        </div>
                    </div>
                    <h2 class="text-2xl font-bold mb-4">나의 크리처 목록 (${userCharacters.length}개)</h2>
                    <div id="profile-char-list" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
                        ${userCharacters.length > 0 ? '' : '<p>아직 소환한 크리처가 없습니다.</p>'}
                    </div>
                </div>
            `;
            
            const listContainer = document.getElementById('profile-char-list');
            userCharacters.forEach(char => listContainer.appendChild(createCharacterCard(char, 'default')));

            if (isMyProfile) {
                document.getElementById('edit-nickname-btn').onclick = () => {
                    document.getElementById('nickname-display').classList.add('hidden');
                    document.getElementById('edit-nickname-btn').classList.add('hidden');
                    document.getElementById('nickname-edit-form').classList.remove('hidden');
                };
                document.getElementById('save-nickname-btn').onclick = async () => {
                    const newNickname = document.getElementById('nickname-input').value.trim();
                    if (newNickname) {
                        const { error } = await supabaseClient.from('battle_profiles').update({ nickname: newNickname }).eq('id', currentUser.id);
                        if (error) { showModal('오류', `<p>닉네임 변경 실패: ${error.message}</p>`); }
                        else { 
                            currentProfile.nickname = newNickname;
                            renderProfileView(profileId);
                        }
                    }
                };
                 document.getElementById('auto-battle-toggle').onchange = async (e) => {
                     const enabled = e.target.checked;
                     const { error } = await supabaseClient.from('battle_profiles').update({ auto_battle_enabled: enabled }).eq('id', currentUser.id);
                     if (error) { 
                         showModal('오류', `<p>설정 저장 실패: ${error.message}</p><p>데이터베이스 RLS 정책이 올바르게 설정되었는지 확인해주세요.</p>`);
                         e.target.checked = !enabled; // Revert checkbox on error
                     } else {
                         currentProfile.auto_battle_enabled = enabled;
                     }
                 };
                 document.getElementById('change-email-form').onsubmit = async (e) => {
                     e.preventDefault();
                     const newEmail = document.getElementById('new-email-input').value;
                     const { error } = await supabaseClient.auth.updateUser(
                         { email: newEmail },
                         { emailRedirectTo: 'https://07150906.vercel.app' }
                     );
                     if (error) {
                         showModal('이메일 변경 오류', `<p>${error.message}</p>`);
                     } else {
                         showModal('확인메일 발송', `<p><strong>${newEmail}</strong>(으)로 이메일 변경 확인 메일을 보냈습니다. 이메일을 확인해주세요.</p>`);
                     }
                 };
                document.getElementById('check-in-btn').onclick = async () => {
                    const today = new Date().toISOString().split('T')[0];
                    if (currentProfile.last_check_in === today) {
                        showModal('출석 체크', '<p>오늘은 이미 출석했습니다.</p>'); return;
                    }
                    if(currentProfile.credits >= 5) {
                        showModal('크레딧 최대', '<p>무료 크레딧은 최대 5개까지 보유할 수 있습니다.</p>'); return;
                    }
                    const newCredits = currentProfile.credits + 1;
                    const { error } = await supabaseClient.from('battle_profiles').update({ credits: newCredits, last_check_in: today }).eq('id', currentUser.id);
                    if (error) { showModal('오류', `<p>출석 체크 실패: ${error.message}</p>`); }
                    else { showModal('출석 완료!', '<p>1 크레딧을 획득했습니다!</p>'); }
                };
            }
        };
        
        window.renderAdminView = async function() {
            if (!currentProfile?.is_admin) { navigateTo('pokedex-view'); return; }

            adminViewContainer.innerHTML = `<div class="text-center p-8"><h2 class="text-2xl font-bold">사용자 목록 로딩 중...</h2></div>`;

            const { data: profiles, error } = await supabaseClient.from('battle_profiles').select('*');
            if (error) {
                adminViewContainer.innerHTML = `<p class="text-center text-red-400">사용자 정보를 불러오는 데 실패했습니다.</p>`;
                return;
            }

            adminViewContainer.innerHTML = `
                <div class="max-w-4xl mx-auto p-4">
                    <h2 class="font-title text-4xl text-center mb-8">관리자 페이지</h2>
                    <div class="bg-gray-800 rounded-lg shadow-lg p-6">
                        <h3 class="font-bold text-xl mb-4">사용자 크레딧 관리</h3>
                        <div id="admin-user-list" class="divide-y divide-gray-700">
                            ${profiles.map(p => `
                                <div class="py-3 flex justify-between items-center flex-wrap gap-2">
                                    <div>
                                        <p class="font-semibold">${p.nickname || '미설정'}</p>
                                        <p class="text-sm text-gray-400">${p.email}</p>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="w-20 text-right">크레딧: ${p.credits}</span>
                                        <input type="number" id="credit-input-${p.id}" class="w-24 p-1 border rounded bg-gray-700 border-gray-600 text-center" value="${p.credits}">
                                        <button data-id="${p.id}" class="save-credit-btn bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600">저장</button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;

            document.querySelectorAll('.save-credit-btn').forEach(btn => {
                btn.onclick = async () => {
                    const userId = btn.dataset.id;
                    const newCredits = document.getElementById(`credit-input-${userId}`).value;
                    if (newCredits === '' || isNaN(newCredits)) {
                        showModal('오류', `<p>유효한 숫자를 입력해주세요.</p>`);
                        return;
                    }
                    const { error } = await supabaseClient.from('battle_profiles').update({ credits: parseInt(newCredits) }).eq('id', userId);
                    if (error) { 
                        showModal('오류', `<p>크레딧 수정 실패: ${error.message}</p>`);
                    } else { 
                        showModal('성공', '<p>크레딧이 성공적으로 수정되었습니다.</p>'); 
                    }
                };
            });
        };
        
        window.renderRankingPodium = async function() {
            const { data, error } = await supabaseClient.from('battle_characters')
                .select('*, profile:battle_profiles(id, nickname, email)')
                .order('rank_points', { ascending: false })
                .limit(3);
            if (error) { console.error('Error fetching podium data:', error); return; }
            const top3 = data.map(c => ({ ...c.data, id: c.id, creator_id: c.creator_id, rank_points: c.rank_points, image_url: c.image_url, profile: c.profile }));
            
            rankingPodiumView.innerHTML = top3.map((char, index) => {
                const creatorName = char.profile?.nickname || char.profile?.email?.split('@')[0] || 'Unknown';
                const imageUrl = `${char.image_url}?width=256&quality=85`;
                return `
                <div class="podium-item podium-${index + 1}" data-char-id="${char.id}">
                    <p class="text-2xl font-bold mb-2">${index === 0 ? '🥇' : index === 1 ? '🥈' : '🥉'}</p>
                    <img src="${imageUrl}" class="podium-img">
                    <div class="podium-base flex flex-col justify-center items-center p-2">
                        <p class="text-lg font-bold">${char.name}</p>
                        <p class="text-sm">${char.rank_points || 1000} RP</p>
                        <p class="text-xs mt-1">by <a href="#" data-profile-id="${char.creator_id}" class="hover:underline">${creatorName}</a></p>
                    </div>
                </div>
            `}).join('');
            if (top3.length === 0) {
                rankingPodiumView.innerHTML = `<p class="text-center text-gray-500 col-span-full">아직 랭킹 데이터가 없습니다.</p>`;
            }
        };

        // --- Event Listeners & Initial Load ---
        function initApp() {
            document.addEventListener('DOMContentLoaded', async () => {
                const { data: { session } } = await supabaseClient.auth.getSession();
                currentUser = session?.user || null;
                await initialDataLoad();
                listenToAuthStateChanges();
                subscribeToChanges();
                document.body.addEventListener('click', setupAudio, { once: true });
            });

            homeBtn.addEventListener('click', () => navigateTo('pokedex-view'));
            generateBtn.addEventListener('click', generateCharacter);
            promptInput.addEventListener('keydown', e => e.key === 'Enter' && generateCharacter());
            goToBattleBtn.addEventListener('click', () => navigateTo('battle-selection-view'));
            goToRankingBtn.addEventListener('click', () => navigateTo('ranking-view'));
            showTypeChartBtn.addEventListener('click', showTypeChartModal);
            showRarityTableBtn.addEventListener('click', showRarityModal);
            loginForm.addEventListener('submit', handleLogin);
            signupForm.addEventListener('submit', handleSignup);
            
            document.getElementById('forgot-password-link').addEventListener('click', (e) => {
                e.preventDefault();
                showModal('비밀번호 재설정', `
                    <p>가입하신 이메일 주소를 입력하시면, 비밀번호를 재설정할 수 있는 링크를 보내드립니다.</p>
                    <form id="reset-password-form" class="mt-4 flex gap-2">
                        <input type="email" id="reset-email-input" class="flex-1 p-2 border rounded-lg bg-gray-700 text-white border-gray-600" placeholder="이메일" required>
                        <button type="submit" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">전송</button>
                    </form>
                `);
                document.getElementById('reset-password-form').onsubmit = async (ev) => {
                    ev.preventDefault();
                    const email = document.getElementById('reset-email-input').value;
                    const { error } = await supabaseClient.auth.resetPasswordForEmail(email, {
                        redirectTo: 'https://07150906.vercel.app'
                    });
                    if (error) {
                        showModal('오류', `<p>비밀번호 재설정 메일 전송에 실패했습니다: ${error.message}</p>`);
                    } else {
                        showModal('메일 전송 완료', `<p><strong>${email}</strong>(으)로 비밀번호 재설정 메일을 보냈습니다. 이메일을 확인해주세요.</p>`);
                    }
                };
            });
            
            // --- Event Delegation for all dynamic lists ---
            document.body.addEventListener('click', (e) => {
                const card = e.target.closest('.pokedex-card, .podium-item');
                if (card) {
                    const profileLink = e.target.closest('[data-profile-id]');
                    if (profileLink) {
                        e.preventDefault();
                        e.stopPropagation();
                        navigateTo('profile-view', profileLink.dataset.profileId);
                    } else if (card.dataset.charId) {
                        navigateTo('detail-view', card.dataset.charId);
                    }
                }
                if (e.target.id === 'load-more-btn') {
                    loadMoreCharacters();
                }
            });

            tabBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    playUiClickSound();
                    const tab = btn.dataset.tab;
                    document.querySelectorAll('.auth-form').forEach(form => form.classList.add('hidden'));
                    document.getElementById(`${tab}-form`).classList.remove('hidden');
                    tabBtns.forEach(b => b.classList.remove('border-[#8abeb7]', 'text-[#8abeb7]'));
                    btn.classList.add('border-[#8abeb7]', 'text-[#8abeb7]');
                });
            });
            if(tabBtns.length > 0) tabBtns[0].click();
            
            filterBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    playUiClickSound();
                    filterBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    activeFilter = btn.dataset.filter;
                    allCharacters = [];
                    currentPage = 0;
                    loadMoreCharacters();
                });
            });
        }
        
        initApp();
    </script>
</body>
</html>

